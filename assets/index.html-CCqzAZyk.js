import { r as resolveComponent, c as createElementBlock, b as createStaticVNode, a as createVNode, o as openBlock } from "./app-Dscgj__W.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _sfc_main = {};
function _sfc_render(_ctx, _cache) {
  const _component_global_config = resolveComponent("global-config");
  return openBlock(), createElementBlock("div", null, [
    _cache[0] || (_cache[0] = createStaticVNode('<h1 id="_3-高可用架构-稳定性的核心" tabindex="-1"><a class="header-anchor" href="#_3-高可用架构-稳定性的核心"><span>3. 高可用架构：稳定性的核心</span></a></h1><p>前端的高可用，不仅要「治已病」，还要「防未病」。通过合理的架构设计，提高系统对各种异常情况的容错能力，让系统在局部出现问题时，仍然能维持整体的可用性，避免发生雪崩效应：</p><h2 id="请求冗余" tabindex="-1"><a class="header-anchor" href="#请求冗余"><span>请求冗余</span></a></h2><p>请求冗余是一种常见的高可用架构设计，旨在提高系统对网络故障和服务异常的容错能力。它通过在前端应用中增加请求的副本数量，确保在某个请求失败或超时的情况下，其他请求仍然能够正常执行，从而保证系统的可用性。</p><p>具体实现方式包括：</p><ul><li><strong>备用请求</strong>：在前端应用中，当一个请求地址不可用时，可以请求备用的地址，如多域名或多入口策略。这样可以避免因网络、链路故障而导致的系统不可用。</li><li><strong>请求重试</strong>：在请求失败或超时的情况下，自动进行重试。重试策略可以根据具体情况进行配置，如指数退避、固定间隔等。</li><li><strong>请求缓存</strong>：对于一些非实时性要求较高的请求，可以在前端进行缓存。这样即使后端服务出现故障，前端仍然可以返回缓存的结果，提高用户体验。</li></ul><p>通过请求冗余的设计，可以有效减少因网络故障或服务异常而导致的系统不可用情况，提高系统的稳定性和可靠性。</p><p>比如：CDN 域名容灾，详见：<a href="https://tech.meituan.com/2022/01/13/phoenix-cdn.html" target="_blank" rel="noopener noreferrer">从0到1：美团端侧CDN容灾解决方案</a></p><h2 id="服务降级" tabindex="-1"><a class="header-anchor" href="#服务降级"><span>服务降级</span></a></h2><p>服务降级不仅是一个后端的高可用策略，同时也是一个前端的高可用策略。</p><p>服务降级是一种在系统负载过高或服务异常时，通过降低服务质量或减少服务功能来保证系统可用性的策略。在前端高可用架构中，服务降级可以应用于以下几个方面：</p><ul><li><strong>功能降级</strong>：在系统负载过高时，可以暂时关闭一些非核心功能，如评论、分享等，以减轻服务器压力。</li><li><strong>数据降级</strong>：在数据获取失败或超时的情况下，可以返回默认数据或历史数据，避免因数据缺失而导致的页面错误。</li><li><strong>界面降级</strong>：在页面渲染失败或加载缓慢的情况下，可以简化页面布局或隐藏部分内容，提高页面的加载速度和可用性。</li></ul><p>通过服务降级的设计，可以在系统出现异常情况时，保证核心功能的可用性，提高用户体验。</p><h2 id="灾备切换" tabindex="-1"><a class="header-anchor" href="#灾备切换"><span>灾备切换</span></a></h2><p>灾备切换是指当系统发生故障或灾难时，能够快速切换到备用系统或备用数据中心，以保障业务的连续性和数据的安全性。在前端高可用架构中，灾备切换通常包括以下几个关键点：</p><ul><li><strong>多活数据中心</strong>：在不同的地理位置建立多个数据中心，每个数据中心都具备完整的业务处理能力。当某个数据中心发生故障时，可以快速切换到其他数据中心继续提供服务。</li><li><strong>数据同步</strong>：通过数据同步机制，确保不同数据中心之间的数据保持一致。这样在切换到备用数据中心时，用户的数据不会丢失或出现不一致的情况。</li><li><strong>自动切换</strong>：建立自动化的灾备切换机制，当检测到故障时，系统能够自动切换到备用数据中心，减少人工干预和故障恢复时间。</li><li><strong>故障演练</strong>：定期进行故障演练，验证灾备切换机制的有效性，并及时发现和解决潜在的问题。</li></ul><h2 id="前端限流" tabindex="-1"><a class="header-anchor" href="#前端限流"><span>前端限流</span></a></h2><p>参考服务端的限流理念，对一些高频触发的前端操作，也可以在前端侧进行限流。比如对某个按钮的点击，在一定时间内只允许触发一次。或对某个输入框的提交，限制提交频率。前端的限流一方面减少了无谓的请求，另一方面也避免了重复请求对服务端的冲击。</p><p>常见的前端限流策略包括：</p><ul><li><strong>请求频率限制</strong>：限制单位时间内的请求次数，超过限制的请求将被拒绝或延迟处理。</li><li><strong>并发请求限制</strong>：限制同时处理的请求数量，避免过多的并发请求导致系统资源耗尽。</li><li><strong>熔断机制</strong>：当后端服务出现故障或响应时间过长时，自动熔断前端请求，防止故障扩散和系统雪崩。</li></ul><p>举个请求频率限制且与用户体验相关的例子：前端经常会有点击某个按钮打开新页面的场景，如果不给按钮添加节流，连续点击按钮会打开多个新页面，影响用户体验。因此需要限制按钮 1s 内仅可点击一次。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> throttle</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;lodash.throttle&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> onBtnClick</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> throttle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">fn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    leading</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    trailing</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="离线化方案" tabindex="-1"><a class="header-anchor" href="#离线化方案"><span>离线化方案</span></a></h2><p>离线化方案是指通过在前端应用中增加离线功能，使得在网络不可用或不稳定的情况下，用户仍然可以正常使用部分功能。</p><p>如 PWA (Progressive Web App) 等离线化技术，将关键的静态资源、数据缓存在本地，即使在无网络的情况下，也能打开页面，执行部分核心功能。这在移动端尤其有用，可以抵御弱网、断网等网络异常。</p><p>常见的离线化策略包括：</p><ul><li><strong>资源缓存</strong>：将静态资源（如 HTML、CSS、JS 等）缓存在本地，使得在离线状态下可以正常加载和渲染页面。</li><li><strong>数据缓存</strong>：将常用的数据缓存在本地，使得在离线状态下可以正常访问和操作数据。</li><li><strong>断点续传</strong>：在网络恢复后，自动恢复未完成的操作或数据同步，提高用户体验。</li></ul><h2 id="故障隔离" tabindex="-1"><a class="header-anchor" href="#故障隔离"><span>故障隔离</span></a></h2><p>利用微前端架构，将一个庞大的前端应用拆分成若干个松耦合的子应用。不同子应用独立开发、独立部署，运行在不同的运行时环境中。当某个子应用出现故障时，不会波及到其他子应用。也可以考虑为每个子应用分配独立的错误监控和告警渠道，做到故障的精细化管理。</p><p>故障隔离可以通过合理的架构设计和故障处理机制，将故障的影响范围限制在最小范围内，避免故障扩散和系统崩溃。</p><h2 id="后端容错" tabindex="-1"><a class="header-anchor" href="#后端容错"><span>后端容错</span></a></h2><p>除了前端要做好容错，还要反向要求后端服务也要有足够的容错能力，比如接口的幂等性设计、请求的重试机制、服务的主从切换等。只有前后端协同，共建稳定，才能真正实现全链路的高可用。</p><p>后端容错是指通过在后端服务中增加容错机制，提高系统的稳定性和可靠性。常见的后端容错策略包括：</p><ul><li><strong>幂等性设计</strong>：幂等性是指对同一个接口的多次调用，返回的结果是一致的，不会因为多次调用而产生副作用。幂等性是容错的基础，可以确保在请求重试或者并发调用时，不会引入数据不一致或者重复处理的问题。</li><li><strong>请求重试机制</strong>：当请求失败时，自动进行重试，直到请求成功或者达到最大重试次数。重试可以提高请求的成功率，减少因为网络抖动、服务瞬时不可用等原因导致的请求失败。但重试也要把握好度，避免无休止的重试加剧系统的负载。</li><li><strong>服务降级</strong>：当服务负载过高或者出现故障时，主动关闭非核心功能，释放资源确保核心功能的可用性。降级可以防止服务因为过载而完全瘫痪。</li><li><strong>数据校验</strong>：在接收到前端请求时，对请求参数进行校验，避免因参数错误而导致的系统异常。</li><li><strong>异常处理</strong>：在服务内部增加异常处理机制，当出现异常时能够进行合理的处理和恢复。</li><li><strong>服务熔断</strong>：当依赖的下游服务出现故障时，主动切断对下游服务的请求，避免故障传递和放大。熔断可以防止因为个别服务的故障而引发整个系统的级联失败。</li><li><strong>服务限流</strong>：对请求的速率进行控制，避免服务因为突发的高并发流量而过载。限流可以保护服务的稳定性，避免因为个别客户端的异常流量而影响其他客户端。</li><li><strong>服务隔离</strong>：将不同的服务部署在不同的机器或者容器中，避免单个服务的故障影响到其他服务。隔离可以提高故障的隔离性和系统的可扩展性。</li></ul><h2 id="模块化与组件化" tabindex="-1"><a class="header-anchor" href="#模块化与组件化"><span>模块化与组件化</span></a></h2><p>模块化和组件化是高可用架构的重要实践，对于提高代码质量、降低维护成本，提高整体可用性有着重要意义。</p><p><strong>模块化</strong>是指将前端代码划分为独立、可复用的模块，每个模块有明确的职责和边界。通过模块化，可以解决前端代码的耦合、重复问题，提高代码的可读性和可维护性。常见的前端模块化规范有 CommonJS、AMD、ES Module 等。</p><p><strong>组件化</strong>是指将 UI 和功能封装为独立、可复用的组件，每个组件有自己的状态、属性、事件等。通过组件化，可以提高 UI 开发的效率和一致性，方便进行功能复用和扩展。现代前端框架如 React、Vue、Angular 等，都提供了组件化的开发模式。</p><p>要实践好模块化和组件化，需要遵循以下原则：</p><ul><li><strong>单一职责</strong>：一个模块或组件只负责一个功能，避免职责混乱。</li><li><strong>松耦合</strong>：模块或组件之间的依赖关系要明确、最小化，避免紧耦合。</li><li><strong>可复用</strong>：模块或组件要提供通用的接口，方便在不同场景下复用。</li><li><strong>可测试</strong>：模块或组件要容易编写单元测试，保证功能的正确性。</li><li><strong>易维护</strong>：模块或组件的代码要简洁、易读、易修改，降低维护成本。</li></ul><p>除了技术实现，模块化和组件化还需要有配套的管理机制，如模块注册、版本管理、文档生成等，以提高复用效率和降低维护成本。</p><p>通过模块化和组件化，可以将复杂的前端应用划分为清晰、可管理的模块和组件，提高代码的质量和复用性，降低 Bug 引入的风险，最终提升前端的稳定性。</p><p>通过以上几个方面的综合设计和优化，可以有效提高前端应用的高可用性，保障业务的连续性和用户体验。</p>', 43)),
    createVNode(_component_global_config)
  ]);
}
const index_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "index.html.vue"]]);
const data = JSON.parse('{"path":"/front-end-engineering/frontend-stability-construction/high-availability-architecture/","title":"3. 高可用架构：稳定性的核心","lang":"en-US","frontmatter":{"description":"3. 高可用架构：稳定性的核心 前端的高可用，不仅要「治已病」，还要「防未病」。通过合理的架构设计，提高系统对各种异常情况的容错能力，让系统在局部出现问题时，仍然能维持整体的可用性，避免发生雪崩效应： 请求冗余 请求冗余是一种常见的高可用架构设计，旨在提高系统对网络故障和服务异常的容错能力。它通过在前端应用中增加请求的副本数量，确保在某个请求失败或超时...","head":[["meta",{"property":"og:url","content":"https://blog.windstone.cc/front-end-engineering/frontend-stability-construction/high-availability-architecture/"}],["meta",{"property":"og:site_name","content":"风动之石的博客"}],["meta",{"property":"og:title","content":"3. 高可用架构：稳定性的核心"}],["meta",{"property":"og:description","content":"3. 高可用架构：稳定性的核心 前端的高可用，不仅要「治已病」，还要「防未病」。通过合理的架构设计，提高系统对各种异常情况的容错能力，让系统在局部出现问题时，仍然能维持整体的可用性，避免发生雪崩效应： 请求冗余 请求冗余是一种常见的高可用架构设计，旨在提高系统对网络故障和服务异常的容错能力。它通过在前端应用中增加请求的副本数量，确保在某个请求失败或超时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-10-13T04:57:19.000Z"}],["meta",{"property":"article:modified_time","content":"2024-10-13T04:57:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3. 高可用架构：稳定性的核心\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-13T04:57:19.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"请求冗余","slug":"请求冗余","link":"#请求冗余","children":[]},{"level":2,"title":"服务降级","slug":"服务降级","link":"#服务降级","children":[]},{"level":2,"title":"灾备切换","slug":"灾备切换","link":"#灾备切换","children":[]},{"level":2,"title":"前端限流","slug":"前端限流","link":"#前端限流","children":[]},{"level":2,"title":"离线化方案","slug":"离线化方案","link":"#离线化方案","children":[]},{"level":2,"title":"故障隔离","slug":"故障隔离","link":"#故障隔离","children":[]},{"level":2,"title":"后端容错","slug":"后端容错","link":"#后端容错","children":[]},{"level":2,"title":"模块化与组件化","slug":"模块化与组件化","link":"#模块化与组件化","children":[]}],"git":{"createdTime":1728795439000,"updatedTime":1728795439000,"contributors":[{"name":"wind-stone","email":"wind-stone@qq.com","commits":1}]},"readingTime":{"minutes":9.66,"words":2897},"filePathRelative":"front-end-engineering/frontend-stability-construction/high-availability-architecture/index.md","localizedDate":"October 13, 2024","autoDesc":true}');
export {
  index_html as comp,
  data
};
