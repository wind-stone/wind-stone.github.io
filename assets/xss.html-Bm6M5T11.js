import { r as resolveComponent, c as createElementBlock, b as createStaticVNode, a as createVNode, o as openBlock } from "./app-Dscgj__W.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _sfc_main = {};
function _sfc_render(_ctx, _cache) {
  const _component_global_config = resolveComponent("global-config");
  return openBlock(), createElementBlock("div", null, [
    _cache[0] || (_cache[0] = createStaticVNode('<h1 id="xss" tabindex="-1"><a class="header-anchor" href="#xss"><span>XSS</span></a></h1><p>跨站脚本（Cross Site Scripting），为不和层叠样式表（Cascading Style Sheets, CSS）的缩写混淆，故将跨站脚本缩写为 XSS。</p><p>XSS，发生在目标网站中目标用户的浏览器层面上，当用户浏览器渲染整个 HTML 文档的过程中出现了不被预期的脚本指令并执行时，XSS 攻击就会发生。而这段不被预期的脚本，一般是恶意攻击者往 WEB 页面里插入的恶意 Script 代码。</p><p>通俗地可以将 XSS 总结为：想尽一切方法将恶意的基本内容在目标网站中目标用户的浏览器上解析执行。</p><h2 id="xss-分类" tabindex="-1"><a class="header-anchor" href="#xss-分类"><span>XSS 分类</span></a></h2><p>XSS 有三类：</p><ul><li>反射型 XSS（非持久型 XSS）</li><li>存储型 XSS（持久型 XSS）</li><li>DOM XSS</li></ul><h3 id="反射型-xss" tabindex="-1"><a class="header-anchor" href="#反射型-xss"><span>反射型 XSS</span></a></h3><p>发出请求时，XSS 代码出现在 URL 中，作为输入提交到服务端，服务端解析后响应，在响应内容中出现这段 XSS 代码，最后浏览器解析执行。这个过程就像是一次反射，故称为反射型 XSS。</p><p>示例一，<code>http://www.foo.com/xss/reflect1.php</code>的代码如下：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" data-title="php" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">php</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">  echo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> $_GET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;x&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输入<code>x</code>的值未经任何过滤就直接输出，我们可以提交：<code>http://www.foo.com/xss/reflect1.php?x=&lt;script&gt;alert(1)&lt;/script&gt;</code>，服务端解析时，<code>echo</code>就会完整地输出<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>到响应体中，然后浏览器解析执行触发。</p><p>示例二，<code>http://www.foo.com/xss/reflect2.php</code>的代码如下：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" data-title="php" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">php</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">  header</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;Location: &#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">$_GET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;x&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输入<code>x</code>的值作为响应头部的 Location 字段值输出，意味着会发生跳转，触发 XSS 的其中一种方式如下：<br><code>http://www.foo.com/xss/reflect2.php?x=data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5kb21haW4pPC9zY3JpcHQ%2b</code>，跳转到<code>data:</code>协议上，<code>text/html</code>是 MIME 或<code>Content-Type</code>，表明文档类型，<code>base64</code>是指后面字符串的编码方式，后面这段<code>base64</code>解码后的值为：<br><code>&lt;script&gt;alert(document.domain)&lt;/script&gt;</code>，于是，当发生跳转时，就会执行这段 JS。</p><h3 id="存储型-xss" tabindex="-1"><a class="header-anchor" href="#存储型-xss"><span>存储型 XSS</span></a></h3><p>存储型 XSS 和 反射型 XSS 的区别仅在于：提交的 XSS 代码会存储在服务端（不管是数据库、内存还是文件系统等），下次请求目标页面时不用再提交 XSS 代码。</p><p>最典型的例子是留言板 XSS，用户提交一条包含 XSS 代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容会从数据库查询出来并显示，浏览器发现有 XSS 代码，就当做正常的 HTML 与 JS 解析执行，于是就触发了 XSS 攻击。</p><p>存储型 XSS 的攻击是最隐蔽的。</p><h3 id="dom-xss" tabindex="-1"><a class="header-anchor" href="#dom-xss"><span>DOM XSS</span></a></h3><p>与反射型 XSS、存储型 XSS 的差别在于，DOM XSS 的 XSS 代码并不需要服务器解析响应的直接参与，触发 XSS 靠的就是浏览器端的 DOM 解析，可以认为完全是客户端的事情。</p><p>如<code>http://www.foo.com/xssme.html</code>页面里有如下代码：</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" data-title="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  eval</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">location</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">hash</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">substr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>触发 XSS 方式为：<code>http://www.foo.com/xssme.html#alert(1)</code></p><p>这个 URL # 后的内容是不会发送到服务端的，仅仅是在客户端被接收并解析执行。</p><p>针对于 DOM XSS，常见的输入点有：</p><ul><li>document.URL</li><li>document.URLUnencoded</li><li>document.location（以及 location 的多个属性）</li><li>document.referrer</li><li>window.location（以及 location 的多个属性）</li><li><a href="http://window.name" target="_blank" rel="noopener noreferrer">window.name</a></li><li>xhr 请求回来的数据</li><li>document.cookie</li><li>表单项的值</li></ul><p>除了这些输入点，还有可能是用户请求的 HTML 在传输回来时被路由器或者运营商劫持并插入了一段脚本。</p><p>常见的输出点有：</p><ul><li>直接输出 HTML 内容，如 <ul><li>document.write(...)</li><li>document.writeln(...)</li><li>document.body.innerHTML = ...</li></ul></li><li>直接修改 DOM 树（包括 DHTML 事件），如 <ul><li>document.form[0].action = ...（以及其他集合，如：一些对象的 src/href 属性等）</li><li>document.attachEvent(...)</li><li>document.create(...)</li><li>document.execCommand(...)</li><li><a href="http://document.body.xxx" target="_blank" rel="noopener noreferrer">document.body.xxx</a> （直接通过 body 对象访问 DOM）</li><li>window.attachEvent(...)</li></ul></li><li>替换 document URL，如 <ul><li>document.location = ...（以及直接赋值给 location 的 href、host、hostname 属性）</li><li>document.location.hostname = ...</li><li>document.location.replace(...)</li><li>document.location.assign(...)</li><li>document.URL = ...</li><li>window.navigate(...)</li></ul></li><li>打开或修改新窗口，如 <ul><li>document.open(...)</li><li>window.open(...)</li><li>window.location.href = ...（以及直接赋值给 location 的 href、host、hostname 属性）</li></ul></li><li>直接执行脚本，如 <ul><li>eval(...)</li><li>window.execScript(...)</li><li>window.setInterval(...)</li><li>window.setTimeout(...)</li></ul></li></ul><p>这些都是 JavaScript 的基本点，从这些输入/输出点我们可以看到，DOM XSS 的处理逻辑就在客户端。</p><h3 id="防范措施" tabindex="-1"><a class="header-anchor" href="#防范措施"><span>防范措施</span></a></h3><ul><li>不要引入任何不可信的第三方 JavaScript 到页面里</li><li>不要往 HTML 页面里插入任何不可信数据，如果一定要往 HTML 页面插入数据，一定要： <ul><li>插入到 HTML 标签之间的数据，要进行 HTML Entity 编码</li><li>插入到 HTML 属性里的数据，要进行 HTML 属性编码</li><li>插入到 SCRIPT 里的数据，要进行 SCRIPT 编码</li><li>插入到 STYLE 属性里的数据，要进行 CSS 编码</li><li>插入到 HTML URL 里的数据，要进行 URL 编码</li></ul></li><li>使用富文本时，使用 XSS 规则引擎进行编码过滤</li></ul><p>Reference: <a href="http://blog.jobbole.com/47372/" target="_blank" rel="noopener noreferrer">防御 XSS 攻击的七条原则</a></p>', 34)),
    createVNode(_component_global_config)
  ]);
}
const xss_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "xss.html.vue"]]);
const data = JSON.parse('{"path":"/browser-env/security/xss.html","title":"XSS","lang":"en-US","frontmatter":{"description":"XSS 跨站脚本（Cross Site Scripting），为不和层叠样式表（Cascading Style Sheets, CSS）的缩写混淆，故将跨站脚本缩写为 XSS。 XSS，发生在目标网站中目标用户的浏览器层面上，当用户浏览器渲染整个 HTML 文档的过程中出现了不被预期的脚本指令并执行时，XSS 攻击就会发生。而这段不被预期的脚本，一般是...","head":[["meta",{"property":"og:url","content":"https://blog.windstone.cc/browser-env/security/xss.html"}],["meta",{"property":"og:site_name","content":"风动之石的博客"}],["meta",{"property":"og:title","content":"XSS"}],["meta",{"property":"og:description","content":"XSS 跨站脚本（Cross Site Scripting），为不和层叠样式表（Cascading Style Sheets, CSS）的缩写混淆，故将跨站脚本缩写为 XSS。 XSS，发生在目标网站中目标用户的浏览器层面上，当用户浏览器渲染整个 HTML 文档的过程中出现了不被预期的脚本指令并执行时，XSS 攻击就会发生。而这段不被预期的脚本，一般是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-10-14T09:14:10.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-14T09:14:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"XSS\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-14T09:14:10.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"XSS 分类","slug":"xss-分类","link":"#xss-分类","children":[{"level":3,"title":"反射型 XSS","slug":"反射型-xss","link":"#反射型-xss","children":[]},{"level":3,"title":"存储型 XSS","slug":"存储型-xss","link":"#存储型-xss","children":[]},{"level":3,"title":"DOM XSS","slug":"dom-xss","link":"#dom-xss","children":[]},{"level":3,"title":"防范措施","slug":"防范措施","link":"#防范措施","children":[]}]}],"git":{"createdTime":1760433250000,"updatedTime":1760433250000,"contributors":[{"name":"wind-stone","email":"wind-stone@qq.com","commits":1}]},"readingTime":{"minutes":4.03,"words":1209},"filePathRelative":"browser-env/security/xss.md","localizedDate":"October 14, 2025","autoDesc":true}');
export {
  xss_html as comp,
  data
};
