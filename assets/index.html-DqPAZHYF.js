import { r as resolveComponent, c as createElementBlock, d as createBaseVNode, a as createVNode, e as withCtx, b as createStaticVNode, o as openBlock, f as createTextVNode } from "./app-Dscgj__W.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _sfc_main = {};
const _hoisted_1 = { class: "table-of-contents" };
function _sfc_render(_ctx, _cache) {
  const _component_router_link = resolveComponent("router-link");
  const _component_RouteLink = resolveComponent("RouteLink");
  const _component_global_config = resolveComponent("global-config");
  return openBlock(), createElementBlock("div", null, [
    _cache[14] || (_cache[14] = createBaseVNode("h1", {
      id: "滚动",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#滚动"
      }, [
        createBaseVNode("span", null, "滚动")
      ])
    ], -1)),
    createBaseVNode("nav", _hoisted_1, [
      createBaseVNode("ul", null, [
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#js-相关" }, {
            default: withCtx(() => _cache[0] || (_cache[0] = [
              createTextVNode("JS 相关")
            ])),
            _: 1
          }),
          createBaseVNode("ul", null, [
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#判断元素在视口内" }, {
                default: withCtx(() => _cache[1] || (_cache[1] = [
                  createTextVNode("判断元素在视口内")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#文档滚动加载" }, {
                default: withCtx(() => _cache[2] || (_cache[2] = [
                  createTextVNode("文档滚动加载")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#滚动穿透问题、滚动边界问题" }, {
                default: withCtx(() => _cache[3] || (_cache[3] = [
                  createTextVNode("滚动穿透问题、滚动边界问题")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#滚动穿透问题解决" }, {
                default: withCtx(() => _cache[4] || (_cache[4] = [
                  createTextVNode("滚动穿透问题解决")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#passive-true" }, {
                default: withCtx(() => _cache[5] || (_cache[5] = [
                  createTextVNode("passive: true")
                ])),
                _: 1
              })
            ])
          ])
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#css-相关" }, {
            default: withCtx(() => _cache[6] || (_cache[6] = [
              createTextVNode("CSS 相关")
            ])),
            _: 1
          }),
          createBaseVNode("ul", null, [
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#ios-滚动回弹效果" }, {
                default: withCtx(() => _cache[7] || (_cache[7] = [
                  createTextVNode("iOS 滚动回弹效果")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#position-sticky" }, {
                default: withCtx(() => _cache[8] || (_cache[8] = [
                  createTextVNode("position: sticky")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#滚动条隐藏但可滚动" }, {
                default: withCtx(() => _cache[9] || (_cache[9] = [
                  createTextVNode("滚动条隐藏但可滚动")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#滚动条样式" }, {
                default: withCtx(() => _cache[10] || (_cache[10] = [
                  createTextVNode("滚动条样式")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#锚点切换时-流畅的滚动" }, {
                default: withCtx(() => _cache[11] || (_cache[11] = [
                  createTextVNode("锚点切换时，流畅的滚动")
                ])),
                _: 1
              })
            ])
          ])
        ])
      ])
    ]),
    _cache[15] || (_cache[15] = createStaticVNode('<h2 id="js-相关" tabindex="-1"><a class="header-anchor" href="#js-相关"><span>JS 相关</span></a></h2><h3 id="判断元素在视口内" tabindex="-1"><a class="header-anchor" href="#判断元素在视口内"><span>判断元素在视口内</span></a></h3><p>当你需要实现图片懒加载或者无限滚动时，需要确定元素是否出现在视窗中。这可以在事件监听器中处理，最常见的解决方案是使用<code>element.getBoundingClientRect()</code>：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">addEventListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;scroll&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> rect</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> elem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBoundingClientRect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // rect.left/top/right/bottom 是相对于视口的左上角位置而言的</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 判断整个元素是否完全在视口之内</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> inViewport</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> rect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">bottom</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> rect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">right</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &amp;&amp;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">                     rect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">left</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">innerWidth</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &amp;&amp;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">                     rect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">top</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">innerHeight</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的问题在于每次调用<code>getBoundingClientRect</code>时都会触发回流，严重地影响了性能。在事件处理函数中调用（<code>getBoundingClientRect</code>）尤为糟糕，就算使用了函数节流（的技巧）也可能对性能没多大帮助。<br> （回流是指浏览器为局部或整体地重绘某个元素，需要重新计算该元素在文档中的位置与形状。）</p><p>在2016年后，可以通过使用 Intersection Observer 这一 API 来解决问题。它允许你追踪目标元素与其祖先元素或视窗的交叉状态。此外，尽管只有一部分元素出现在视窗中，哪怕只有一像素，也可以选择触发回调函数：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> observer</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> IntersectionObserver</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">callback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">options</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">observer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">observe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">element</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>此 API 被广泛地支持，但仍有一些浏览器需要 polyfill。尽管如此，它仍是目前最好的解决方案。</p><h3 id="文档滚动加载" tabindex="-1"><a class="header-anchor" href="#文档滚动加载"><span>文档滚动加载</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">addEventListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;scroll&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 获取文档的垂直滚动距离</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> documentScrollY</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">pageYOffset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 获取文档的高度</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> documentHeight</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">body</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">offsetHeight</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 获取视口高度</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> viewPortHeight</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">innerHeight</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 文档底部距离视口底部的距离</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> leftDistance</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> documentHeight</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> documentScrollY</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> viewPortHeight</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">leftDistance</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &lt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 文档滑动时，文档底部距离视口底部还有 20 px 时，加载新数据</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="滚动穿透问题、滚动边界问题" tabindex="-1"><a class="header-anchor" href="#滚动穿透问题、滚动边界问题"><span>滚动穿透问题、滚动边界问题</span></a></h3><p>如果你的弹框或下拉列表是可滚动的，那你务必要了解连锁滚动相关的问题：当用户滚动到（弹框或下拉列表）末尾（后再继续滚动时），整个页面都会开始滚动。</p><h3 id="滚动穿透问题解决" tabindex="-1"><a class="header-anchor" href="#滚动穿透问题解决"><span>滚动穿透问题解决</span></a></h3>', 13)),
    createBaseVNode("ul", null, [
      _cache[13] || (_cache[13] = createBaseVNode("li", null, [
        createBaseVNode("a", {
          href: "https://juejin.im/post/5abf1c69f265da239706fcb8",
          target: "_blank",
          rel: "noopener noreferrer"
        }, "移动端滚动穿透解决方案")
      ], -1)),
      createBaseVNode("li", null, [
        createVNode(_component_RouteLink, { to: "/browser-env/scroll/no-bg-scroll.html" }, {
          default: withCtx(() => _cache[12] || (_cache[12] = [
            createTextVNode("示例代码")
          ])),
          _: 1
        })
      ])
    ]),
    _cache[16] || (_cache[16] = createStaticVNode('<h3 id="passive-true" tabindex="-1"><a class="header-anchor" href="#passive-true"><span><code>passive: true</code></span></a></h3><p><code>addEventListener(type, listener[, options ])</code>里<code>options</code>里的<code>passive</code>参数，设置为<code>true</code>时，表明注册的<code>listener</code>内不会调用<code>preventDefault()</code>，浏览器将同时执行<code>listener</code>和浏览器的默认行为（而不是等执行<code>listener</code>结束之后再执行默认行为），且会忽略<code>listener</code>里的<code>preventDefault()</code>，使得滚动更加流畅。</p><p>Reference:</p><ul><li><a href="https://github.com/justjavac/the-front-end-knowledge-you-may-not-know/issues/6#issuecomment-404205665" target="_blank" rel="noopener noreferrer">addEventListener 的第三个参数</a></li><li><a href="http://www.cnblogs.com/ziyunfei/p/5545439.html" target="_blank" rel="noopener noreferrer">passive 的事件监听器</a></li><li><a href="https://mp.weixin.qq.com/s/TrN50625KykugTiOZ3JVsw" target="_blank" rel="noopener noreferrer">前端早读课--【第1240期】passive 事件监听</a></li></ul><h2 id="css-相关" tabindex="-1"><a class="header-anchor" href="#css-相关"><span>CSS 相关</span></a></h2><h3 id="ios-滚动回弹效果" tabindex="-1"><a class="header-anchor" href="#ios-滚动回弹效果"><span>iOS 滚动回弹效果</span></a></h3><p>iOS 上若不做处理，滚动将显得不流畅。此时，可添加一行代码：</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.scroll-area</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">    -webkit-overflow-scrolling</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">touch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>-webkit-overflow-scrolling</code>属性控制元素在移动设备上是否使用滚动回弹效果。</p><p>取值如下：</p><ul><li><code>auto</code><ul><li>Use &quot;regular&quot; scrolling, where the content immediately ceases to scroll when you remove your finger from the touchscreen.</li><li>翻译：使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。 |</li></ul></li><li><code>touch</code><ul><li>Use momentum-based scrolling, where the content continues to scroll for a while after finishing the scroll gesture and removing your finger from the touchscreen. The speed and duration of the continued scrolling is proportional to how vigorous the scroll gesture was. Also creates a new stacking context.</li><li>翻译：使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。 |</li></ul></li></ul><p>需要注意的是，对容器添加了<code>-webkit-overflow-scrolling: touch</code>后，可能会存在以下问题：</p><ul><li>导致容器内使用<code>position:fixed;</code>固定定位的元素随着页面一起滚动。</li><li>（iOS UIWebview 里）容器内溢出的内容（比如弹窗）将被隐藏，效果类似于<code>overflow: hidden</code>，google 未找到原因</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>该特性是非标准的，详情请见<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-overflow-scrolling" target="_blank" rel="noopener noreferrer">MDN 之 -webkit-overflow-scrolling</a></p></div><h3 id="position-sticky" tabindex="-1"><a class="header-anchor" href="#position-sticky"><span>position: sticky</span></a></h3><p><code>position: sticky</code>是结合了<code>position: relative</code>和<code>position: fixed</code>两种定位功能于一体的特殊定位，适用于一些特殊场景。</p><p>元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p><p>这个特定阈值指的是<code>top</code>，<code>right</code>，<code>bottom</code>或<code>left</code>之一，换言之，指定<code>top</code>，<code>right</code>，<code>bottom</code>或 <code>left</code>四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><h3 id="滚动条隐藏但可滚动" tabindex="-1"><a class="header-anchor" href="#滚动条隐藏但可滚动"><span>滚动条隐藏但可滚动</span></a></h3><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* Chrome，Safari 和 Opera */</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.container</span><span style="--shiki-light:#986801;--shiki-dark:#56B6C2;">::-webkit-scrollbar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  display: </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">none</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/* IE 或 Edge */</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.container</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">  -ms-overflow-style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">none</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于 Firefox，没有任何办法隐藏滚动条。</p><h3 id="滚动条样式" tabindex="-1"><a class="header-anchor" href="#滚动条样式"><span>滚动条样式</span></a></h3><p>IE 5.5 版本以后，允许修改滚动条的颜色。</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">body</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  scrollbar-face-color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">blue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WebKit 的开发者在 2009 年提出了（修改滚动条）样式的方案。以下是使用 -webkit 前缀在支持相关样式的浏览器中模拟 macOS 滚动条样式的代码：</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#56B6C2;">::-webkit-scrollbar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  width: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">px</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#56B6C2;">::-webkit-scrollbar-thumb</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  background-color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">#</span><span style="--shiki-light:#0184BC;--shiki-dark:#D19A66;">c1c1c1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  border-radius: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">px</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Chrome、Safari、Opera 甚至于 UC 浏览器或者三星自带的桌面浏览器都支持（上述 CSS）。Edge 也有计划实现它们。但三年过去了，该计划仍在中等优先级中（而尚未被实现）。</p><h3 id="锚点切换时-流畅的滚动" tabindex="-1"><a class="header-anchor" href="#锚点切换时-流畅的滚动"><span>锚点切换时，流畅的滚动</span></a></h3><p>通过锚点链接来跳转到页面上的不同区块时，若想实现平滑地滚动，可添加一行代码：</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">html</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  scroll-behavior: </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">smooth</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前<code>scroll-behavior</code>仅在 Chrome、 Firefox 与 Opera 上被支持，但我们希望它能被广泛支持，因为使用 CSS （比使用 JavaScript）在解决页面滚动问题时优雅得多，并更符合“渐进增强”的模式。</p><p>Reference：</p><ul><li><a href="https://mp.weixin.qq.com/s/tG56t5pd1Kw_O2NBXGAk6Q" target="_blank" rel="noopener noreferrer">【第1286期】滑向未来：现代 JavaScript 与 CSS 滚动实现指南</a></li><li><a href="http://www.cnblogs.com/coco1s/p/6402723.html" target="_blank" rel="noopener noreferrer">使用 position:sticky 实现粘性布局</a></li></ul>', 33)),
    createVNode(_component_global_config)
  ]);
}
const index_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "index.html.vue"]]);
const data = JSON.parse('{"path":"/browser-env/scroll/","title":"滚动","lang":"en-US","frontmatter":{"description":"滚动 JS 相关 判断元素在视口内 当你需要实现图片懒加载或者无限滚动时，需要确定元素是否出现在视窗中。这可以在事件监听器中处理，最常见的解决方案是使用element.getBoundingClientRect()： 上述代码的问题在于每次调用getBoundingClientRect时都会触发回流，严重地影响了性能。在事件处理函数中调用（getBou...","head":[["meta",{"property":"og:url","content":"https://blog.windstone.cc/browser-env/scroll/"}],["meta",{"property":"og:site_name","content":"风动之石的博客"}],["meta",{"property":"og:title","content":"滚动"}],["meta",{"property":"og:description","content":"滚动 JS 相关 判断元素在视口内 当你需要实现图片懒加载或者无限滚动时，需要确定元素是否出现在视窗中。这可以在事件监听器中处理，最常见的解决方案是使用element.getBoundingClientRect()： 上述代码的问题在于每次调用getBoundingClientRect时都会触发回流，严重地影响了性能。在事件处理函数中调用（getBou..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2021-12-09T12:57:56.000Z"}],["meta",{"property":"article:modified_time","content":"2021-12-09T12:57:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"滚动\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2021-12-09T12:57:56.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"JS 相关","slug":"js-相关","link":"#js-相关","children":[{"level":3,"title":"判断元素在视口内","slug":"判断元素在视口内","link":"#判断元素在视口内","children":[]},{"level":3,"title":"文档滚动加载","slug":"文档滚动加载","link":"#文档滚动加载","children":[]},{"level":3,"title":"滚动穿透问题、滚动边界问题","slug":"滚动穿透问题、滚动边界问题","link":"#滚动穿透问题、滚动边界问题","children":[]},{"level":3,"title":"滚动穿透问题解决","slug":"滚动穿透问题解决","link":"#滚动穿透问题解决","children":[]},{"level":3,"title":"passive: true","slug":"passive-true","link":"#passive-true","children":[]}]},{"level":2,"title":"CSS 相关","slug":"css-相关","link":"#css-相关","children":[{"level":3,"title":"iOS 滚动回弹效果","slug":"ios-滚动回弹效果","link":"#ios-滚动回弹效果","children":[]},{"level":3,"title":"position: sticky","slug":"position-sticky","link":"#position-sticky","children":[]},{"level":3,"title":"滚动条隐藏但可滚动","slug":"滚动条隐藏但可滚动","link":"#滚动条隐藏但可滚动","children":[]},{"level":3,"title":"滚动条样式","slug":"滚动条样式","link":"#滚动条样式","children":[]},{"level":3,"title":"锚点切换时，流畅的滚动","slug":"锚点切换时-流畅的滚动","link":"#锚点切换时-流畅的滚动","children":[]}]}],"git":{"createdTime":1533973348000,"updatedTime":1639054676000,"contributors":[{"name":"wind-stone","email":"wind-stone@qq.com","commits":3}]},"readingTime":{"minutes":5.09,"words":1527},"filePathRelative":"browser-env/scroll/README.md","localizedDate":"August 11, 2018","autoDesc":true}');
export {
  index_html as comp,
  data
};
