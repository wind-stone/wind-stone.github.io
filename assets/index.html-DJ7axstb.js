import { r as resolveComponent, c as createElementBlock, d as createBaseVNode, a as createVNode, e as withCtx, b as createStaticVNode, o as openBlock, f as createTextVNode } from "./app-Dscgj__W.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _sfc_main = {};
const _hoisted_1 = { class: "table-of-contents" };
function _sfc_render(_ctx, _cache) {
  const _component_router_link = resolveComponent("router-link");
  const _component_global_config = resolveComponent("global-config");
  return openBlock(), createElementBlock("div", null, [
    _cache[6] || (_cache[6] = createBaseVNode("h1", {
      id: "需要经常使用的方法",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#需要经常使用的方法"
      }, [
        createBaseVNode("span", null, "需要经常使用的方法")
      ])
    ], -1)),
    createBaseVNode("nav", _hoisted_1, [
      createBaseVNode("ul", null, [
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#字符串" }, {
            default: withCtx(() => _cache[0] || (_cache[0] = [
              createTextVNode("字符串")
            ])),
            _: 1
          })
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#数值" }, {
            default: withCtx(() => _cache[1] || (_cache[1] = [
              createTextVNode("数值")
            ])),
            _: 1
          })
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#数组" }, {
            default: withCtx(() => _cache[2] || (_cache[2] = [
              createTextVNode("数组")
            ])),
            _: 1
          })
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#正则表达式" }, {
            default: withCtx(() => _cache[3] || (_cache[3] = [
              createTextVNode("正则表达式")
            ])),
            _: 1
          })
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#函数" }, {
            default: withCtx(() => _cache[4] || (_cache[4] = [
              createTextVNode("函数")
            ])),
            _: 1
          })
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#对象" }, {
            default: withCtx(() => _cache[5] || (_cache[5] = [
              createTextVNode("对象")
            ])),
            _: 1
          })
        ])
      ])
    ]),
    _cache[7] || (_cache[7] = createStaticVNode('<h2 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串"><span>字符串</span></a></h2><table><thead><tr><th>项目</th><th>ECMAScript 版本</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>str.codePointAt()</code></td><td>ES6</td><td>返回一个字符的码点</td><td>能够正确处理 4 个字节储存的字符（（Unicode 码点大于<code>0xFFFF</code>的字符））</td></tr><tr><td><code>String.fromCodePoint()</code></td><td>ES6</td><td>从码点返回对应字符</td><td>可以识别大于<code>0xFFFF</code>的字符，弥补了String.fromCharCode方法的不足</td></tr><tr><td><code>for (let ch of str)</code></td><td>ES6</td><td>字符串的遍历器接口</td><td></td></tr><tr><td><code>str.at()</code></td><td>提案</td><td>返回对应位置的字符</td><td>可以识别 Unicode 编号大于<code>0xFFFF</code>的字符，</td></tr><tr><td><code>str.normalize()</code></td><td>ES6</td><td>将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化</td><td></td></tr><tr><td><code>str.includes()</code></td><td>ES6</td><td>返回布尔值，表示是否找到了参数字符串</td><td>支持第二个参数，表示开始搜索的位置，能识别出<code>NaN</code></td></tr><tr><td><code>str.startsWith()</code></td><td>ES6</td><td>返回布尔值，表示参数字符串是否在原字符串的头部</td><td>支持第二个参数，表示开始搜索的位置</td></tr><tr><td><code>str.endsWith()</code></td><td>ES6</td><td>返回布尔值，表示参数字符串是否在原字符串的头部</td><td>支持第二个参数，表示开始搜索的位置，针对前 n 个字符</td></tr><tr><td><code>str.repeat()</code></td><td>ES6</td><td>返回一个新字符串，表示将原字符串重复n次。</td><td></td></tr><tr><td><code>str.matchAll()</code></td><td>ES6</td><td></td><td></td></tr><tr><td><code>str.padStart()</code></td><td>ES2017</td><td>返回一个新字符串，表示将原字符串重复n次。</td><td></td></tr><tr><td><code>str.padEnd()</code></td><td>ES2017</td><td>某个字符串不够指定长度，会在头部补全</td><td></td></tr><tr><td>模板字符串</td><td></td><td></td><td></td></tr><tr><td><code>String.raw()</code></td><td>ES6</td><td>返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串</td><td></td></tr></tbody></table><h2 id="数值" tabindex="-1"><a class="header-anchor" href="#数值"><span>数值</span></a></h2><ul><li>Number 方法上新增的静态方法</li></ul><table><thead><tr><th>项目</th><th>ECMAScript 版本</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>Number.isFinite()</code></td><td>ES6</td><td>检查一个数值是否为有限的（finite），即不是<code>Infinity</code></td><td>如果参数类型不是数值，一律返回<code>false</code></td></tr><tr><td><code>Number.isNaN()</code></td><td>ES6</td><td>检查一个值是否为<code>NaN</code></td><td>如果参数类型不是数值，一律返回<code>false</code></td></tr><tr><td><code>Number.parseInt()</code></td><td>ES6</td><td>同全局方法<code>parseInt()</code></td><td>减少全局性方法，使得语言逐步模块化</td></tr><tr><td><code>Number.parseFloat()</code></td><td>ES6</td><td>同全局方法<code>parseFloat()</code></td><td>减少全局性方法，使得语言逐步模块化</td></tr><tr><td><code>Number.isInteger()</code></td><td>ES6</td><td>判断一个数值是否为整数</td><td>如果参数不是数值，返回<code>false</code></td></tr><tr><td><code>Number.EPSILON</code></td><td>ES6</td><td>常量，JavaScript 能够表示的最小精度</td><td>对于 64 位浮点数来说，就等于 2 的 -52 次方</td></tr><tr><td><code>Number.MAX_SAFE_INTEGER</code></td><td>ES6</td><td>常量，最大安全整数</td><td>值为<code>Math.pow(2, 53) - 1</code>，即 9007199254740991</td></tr><tr><td><code>Number.MIN_SAFE_INTEGER</code></td><td>ES6</td><td>常量，最小安全整数</td><td>值为<code>-Math.pow(2, 53) + 1</code>，即 -9007199254740991</td></tr><tr><td><code>Number.isSafeInteger()</code></td><td>ES6</td><td>判断整数是否在最大最小安全整数之间，即在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点）之间</td><td>如果参数不是整数，一律返回<code>false</code></td></tr></tbody></table><ul><li>Math 方法上新增的静态方法</li></ul><table><thead><tr><th>项目</th><th>ECMAScript 版本</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>Math.trunc()</code></td><td>ES6</td><td>去除一个数的小数部分，返回整数部分</td><td>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值；对于空值和无法截取整数的值，返回<code>NaN</code></td></tr><tr><td><code>Math.sign()</code></td><td>ES6</td><td>判断一个数到底是正数、负数、还是零</td><td>对于非数值，会先将其转换为数值。</td></tr><tr><td><code>Math.cbrt()</code></td><td>ES6</td><td>计算一个数的立方根</td><td>对于非数值，<code>Math.cbrt</code>方法内部也是先使用<code>Number</code>方法将其转为数值</td></tr><tr><td><code>Math.clz32()</code></td><td>ES6</td><td>返回一个数的 32 位无符号整数形式有多少个前导 0</td><td></td></tr><tr><td><code>Math.imul()</code></td><td>ES6</td><td>返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</td><td></td></tr><tr><td><code>Math.fround()</code></td><td>ES6</td><td>返回一个数的 32 位单精度浮点数形式</td><td></td></tr><tr><td><code>Math.hypot()</code></td><td>ES6</td><td>返回所有参数的平方和的平方根</td><td></td></tr><tr><td><code>Math.expm1()</code></td><td>ES6</td><td>返回 <code>Math.exp(x) - 1</code></td><td></td></tr><tr><td><code>Math.log1p()</code></td><td>ES6</td><td>返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code></td><td></td></tr><tr><td><code>Math.log10()</code></td><td>ES6</td><td>返回以 10 为底的 x 的对数</td><td></td></tr><tr><td><code>Math.log2()</code></td><td>ES6</td><td>返回以 2 为底的x的对数</td><td></td></tr><tr><td><code>Math.sinh(x)</code></td><td>ES6</td><td>返回 x 的双曲正弦（hyperbolic sine）</td><td></td></tr><tr><td><code>Math.cosh(x)</code></td><td>ES6</td><td>返回 x 的双曲余弦（hyperbolic cosine）</td><td></td></tr><tr><td><code>Math.tanh(x)</code></td><td>ES6</td><td>返回 x 的双曲正切（hyperbolic tangent）</td><td></td></tr><tr><td><code>Math.asinh(x)</code></td><td>ES6</td><td>返回 x 的反双曲正弦（inverse hyperbolic sine）</td><td></td></tr><tr><td><code>Math.acosh(x)</code></td><td>ES6</td><td>返回 x 的反双曲余弦（inverse hyperbolic cosine）</td><td></td></tr><tr><td><code>Math.atanh(x)</code></td><td>ES6</td><td>返回 x 的反双曲正切（inverse hyperbolic tangent）</td><td></td></tr></tbody></table><ul><li>新增的运算符</li></ul><table><thead><tr><th>项目</th><th>ECMAScript 版本</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>**</code></td><td>ES6</td><td>指数运算符</td><td><code>2 ** 2 // 4</code></td></tr><tr><td><code>**=</code></td><td>ES6</td><td>指数运算符可以与等号结合，形成一个新的赋值运算符</td><td><code>b **= 3; // 等同于 b = b * b * b;</code></td></tr></tbody></table><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h2><table><thead><tr><th>项目</th><th>ECMAScript 版本</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>Array.isArray</code></td><td>ES5</td><td>判断参数是否是数组</td><td></td></tr><tr><td><code>...</code>（扩展运算符）</td><td>ES6</td><td>将数组转为用逗号分隔的参数序列</td><td>注意与函数的<code>rest</code>参数区分开</td></tr><tr><td><code>Array.from()</code></td><td>ES6</td><td>将两类对象（类似数组的对象、可遍历的对象）转为真正的数组</td><td>1、可遍历的对象包括 ES6 新增的数据结构 Set 和 Map；2、该方法可以接受第二、三个参数</td></tr><tr><td><code>Array.of()</code></td><td>ES6</td><td>将一组值转换为数组</td><td><code>Array.of(3, 11, 8) // [3,11,8]</code></td></tr><tr><td><code>array.copyWithin()</code></td><td>ES6</td><td>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</td><td>调用该方法会修改当前数组</td></tr><tr><td><code>array.find(fn)</code></td><td>ES6</td><td>找出第一个符合条件的数组成员</td><td>类似于<code>some</code>，但是会返回匹配的元素</td></tr><tr><td><code>array.findIndex(fn)</code></td><td>ES 2015</td><td>找出第一个符合条件的数组索引</td><td>类似于<code>some</code>，但是会返回匹配的元素的索引</td></tr><tr><td><code>array.fill()</code></td><td>ES6</td><td>将数组所有元素替换成给定值</td><td>第二、三个参数指定替换的起始结束位置</td></tr><tr><td><code>array.entries()</code></td><td>ES6</td><td>遍历数组的键值对，返回遍历器对象</td><td></td></tr><tr><td><code>array.keys()</code></td><td>ES6</td><td>遍历数组的键名，返回遍历器对象</td><td></td></tr><tr><td><code>array.values()</code></td><td>ES6</td><td>遍历数组的键值，返回遍历器对象</td><td></td></tr><tr><td><code>array.includes()</code></td><td>ES2016</td><td>检测数组是否包含给定的值，返回布尔值</td><td>类似字符串的<code>includes</code>方法</td></tr></tbody></table><p>注意：</p><ul><li>使用这些方法时，请详细<a href="http://es6.ruanyifeng.com/#docs/array" target="_blank" rel="noopener noreferrer">查阅文档</a>，方法可能存在多个参数的情况</li><li>数组里避免使用<a href="http://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D" target="_blank" rel="noopener noreferrer">空位</a></li></ul><h2 id="正则表达式" tabindex="-1"><a class="header-anchor" href="#正则表达式"><span>正则表达式</span></a></h2><table><thead><tr><th>项目</th><th>ECMAScript 版本</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>new RegExp(/xyz/, &#39;i&#39;)</code></td><td>ES6</td><td>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符</td><td>返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符（ES5 不允许第一个参数是正则对象时，存在第二个参数）</td></tr><tr><td><code>RegExp.prototype[Symbol.match]</code></td><td>ES6</td><td>对应<code>String.prototype.match</code></td><td></td></tr><tr><td><code>RegExp.prototype[Symbol.replace]</code></td><td>ES6</td><td>对应<code>String.prototype.replace</code></td><td></td></tr><tr><td><code>RegExp.prototype[Symbol.search]</code></td><td>ES6</td><td>对应<code>String.prototype.search</code></td><td></td></tr><tr><td><code>RegExp.prototype[Symbol.split]</code></td><td>ES6</td><td>对应<code>String.prototype.split</code></td><td></td></tr><tr><td><code>u</code>修饰符</td><td>ES6</td><td>正确处理四个字节的 UTF-16 编码</td><td></td></tr><tr><td><code>y</code>修饰符</td><td>ES6</td><td>“粘连”（sticky）修饰符，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始</td><td></td></tr><tr><td><code>reg.sticky</code></td><td>ES6</td><td>正则对象是否设置了<code>y</code>修饰符</td><td></td></tr><tr><td><code>reg.flags</code></td><td>ES6</td><td>返回正则表达式的修饰符</td><td></td></tr><tr><td><code>s</code>修饰符</td><td>ES6</td><td><code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符</td><td></td></tr><tr><td><code>(?&lt;=)</code></td><td>ES6</td><td>后行断言</td><td></td></tr><tr><td><code>(?&lt;!)</code></td><td>ES6</td><td>后行否定断言</td><td></td></tr><tr><td><code>\\p{...}</code>/<code>\\P{...}</code></td><td>ES6</td><td>允许正则表达式匹配符合 Unicode 某种属性的所有字符</td><td></td></tr><tr><td>具名组匹配</td><td>ES6</td><td>允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用</td><td></td></tr></tbody></table><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h2><table><thead><tr><th>项目</th><th>ECMAScript 版本</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td>函数参数的默认值</td><td>ES6</td><td></td><td></td></tr><tr><td><code>fn.length</code></td><td>ES6</td><td>返回没有指定默认值的参数个数</td><td>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数</td></tr><tr><td><code>...values</code>（<code>rest</code>参数）</td><td>ES6</td><td>获取函数的多余参数，<code>values</code>是参数数组</td><td>仅用于函数声明时，注意与数组的扩展运算符的区别</td></tr><tr><td><code>=&gt;</code>（箭头函数）</td><td>ES6</td><td>箭头函数没有自己的<code>this</code>，使用的是外部的<code>this</code></td><td>尽量使用箭头函数</td></tr><tr><td><code>::</code>（双冒号运算符）</td><td>提案</td><td>“函数绑定”运算符，用来取代<code>call</code>、<code>apply</code>、<code>bind</code>调用</td><td>示例：<code>foo::bar;</code>等同于<code>bar.bind(foo);</code></td></tr><tr><td>尾调用优化</td><td>ES6</td><td></td><td>ES6 第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</td></tr><tr><td>函数参数的尾逗号</td><td>ES2017</td><td>函数的最后一个参数有尾逗号</td><td></td></tr></tbody></table><h2 id="对象" tabindex="-1"><a class="header-anchor" href="#对象"><span>对象</span></a></h2><table><thead><tr><th>项目</th><th>ECMAScript 版本</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>...</code>扩展运算符</td><td></td><td></td><td></td></tr><tr><td>属性名表达式</td><td>ES6</td><td>允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内</td><td><code>let example = &#39;xxx&#39;; const obj = { [example]: true }</code></td></tr><tr><td>方法的<code>name</code>属性</td><td>ES6</td><td>对象方法也有<code>name</code>属性</td><td>需要注意<code>bind</code>方法创造的函数、Function 构造函数创造的函数</td></tr><tr><td><code>Object.is()</code></td><td>ES6</td><td>比较两个值是否相等，采用“Same-value equality”（同值相等）算法</td><td>与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</td></tr><tr><td><code>Object.assign()</code></td><td>ES6</td><td>将源对象（source）的所有可枚举且是自身的属性，复制到目标对象（target）</td><td>target source 只有对象和字符串可用，别的类型会忽略</td></tr><tr><td><code>Object.getOwnPropertyDescriptors()</code></td><td>ES2017</td><td>获取指定对象所有自身属性（非继承属性）的描述对象。</td><td>包括不可枚举属性</td></tr><tr><td><code>__proto__</code></td><td>ES6</td><td>读取或设置当前对象的<code>prototype</code>对象</td><td>只有浏览器必须部署这个属性，其他运行环境不一定需要部署</td></tr><tr><td><code>Object.setPrototypeOf()</code></td><td>ES6</td><td>设置对象的<code>__proto__</code></td><td>这是 ES6 正式推荐的设置原型对象的方法</td></tr><tr><td><code>Object.getPrototypeOf()</code></td><td>ES6</td><td>获取对象的<code>__proto__</code></td><td></td></tr><tr><td><code>super</code>关键字</td><td>ES6</td><td>指向当前对象的原型对象</td><td><code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错；目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</td></tr><tr><td><code>Object.keys()</code></td><td>ES5</td><td>数组，对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</td><td></td></tr><tr><td><code>Object.values()</code></td><td>ES2017</td><td>数组，对象自身的（不含继承的）所有可遍历（enumerable）属性的键值</td><td>过滤属性名为 Symbol 值的属性</td></tr><tr><td><code>Object.entries()</code></td><td>ES2017</td><td>数组，成员是对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组</td><td></td></tr></tbody></table>', 19)),
    createVNode(_component_global_config)
  ]);
}
const index_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "index.html.vue"]]);
const data = JSON.parse('{"path":"/es6/","title":"需要经常使用的方法","lang":"en-US","frontmatter":{"description":"需要经常使用的方法 字符串 数值 Number 方法上新增的静态方法 Math 方法上新增的静态方法 新增的运算符 数组 注意： 使用这些方法时，请详细查阅文档，方法可能存在多个参数的情况 数组里避免使用空位 正则表达式 函数 对象","head":[["meta",{"property":"og:url","content":"https://blog.windstone.cc/es6/"}],["meta",{"property":"og:site_name","content":"风动之石的博客"}],["meta",{"property":"og:title","content":"需要经常使用的方法"}],["meta",{"property":"og:description","content":"需要经常使用的方法 字符串 数值 Number 方法上新增的静态方法 Math 方法上新增的静态方法 新增的运算符 数组 注意： 使用这些方法时，请详细查阅文档，方法可能存在多个参数的情况 数组里避免使用空位 正则表达式 函数 对象"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2021-06-14T18:08:13.000Z"}],["meta",{"property":"article:modified_time","content":"2021-06-14T18:08:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"需要经常使用的方法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2021-06-14T18:08:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"字符串","slug":"字符串","link":"#字符串","children":[]},{"level":2,"title":"数值","slug":"数值","link":"#数值","children":[]},{"level":2,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":2,"title":"正则表达式","slug":"正则表达式","link":"#正则表达式","children":[]},{"level":2,"title":"函数","slug":"函数","link":"#函数","children":[]},{"level":2,"title":"对象","slug":"对象","link":"#对象","children":[]}],"git":{"createdTime":1521032325000,"updatedTime":1623694093000,"contributors":[{"name":"wind-stone","email":"wind-stone@qq.com","commits":3}]},"readingTime":{"minutes":8.47,"words":2540},"filePathRelative":"es6/README.md","localizedDate":"March 14, 2018","autoDesc":true}');
export {
  index_html as comp,
  data
};
