import { r as resolveComponent, c as createElementBlock, d as createBaseVNode, a as createVNode, e as withCtx, b as createStaticVNode, o as openBlock, f as createTextVNode } from "./app-DNVdkGQA.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _imports_0 = "/assets/number-64-bit-DuE1tTfq.png";
const _imports_1 = "/assets/scientific-notation-origin-BnmUeGBn.png";
const _imports_2 = "/assets/scientific-notation-final-BMFZll8v.png";
const _imports_3 = "/assets/number-4.5-DxuvUyKs.png";
const _imports_4 = "/assets/number-0.1-B4DPYXlb.png";
const _sfc_main = {};
const _hoisted_1 = { class: "table-of-contents" };
function _sfc_render(_ctx, _cache) {
  const _component_router_link = resolveComponent("router-link");
  const _component_global_config = resolveComponent("global-config");
  return openBlock(), createElementBlock("div", null, [
    _cache[20] || (_cache[20] = createBaseVNode("h1", {
      id: "javascript-关于-ieee-754-双精度浮点数的实现",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#javascript-关于-ieee-754-双精度浮点数的实现"
      }, [
        createBaseVNode("span", null, "JavaScript 关于 IEEE 754 双精度浮点数的实现")
      ])
    ], -1)),
    createBaseVNode("nav", _hoisted_1, [
      createBaseVNode("ul", null, [
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#简介" }, {
            default: withCtx(() => _cache[0] || (_cache[0] = [
              createTextVNode("简介")
            ])),
            _: 1
          })
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#【存储误差】双精度浮点数的存储" }, {
            default: withCtx(() => _cache[1] || (_cache[1] = [
              createTextVNode("【存储误差】双精度浮点数的存储")
            ])),
            _: 1
          }),
          createBaseVNode("ul", null, [
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#科学计数法" }, {
                default: withCtx(() => _cache[2] || (_cache[2] = [
                  createTextVNode("科学计数法")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#符号位" }, {
                default: withCtx(() => _cache[3] || (_cache[3] = [
                  createTextVNode("符号位")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#指数位" }, {
                default: withCtx(() => _cache[4] || (_cache[4] = [
                  createTextVNode("指数位")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#尾数位" }, {
                default: withCtx(() => _cache[5] || (_cache[5] = [
                  createTextVNode("尾数位")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#总结" }, {
                default: withCtx(() => _cache[6] || (_cache[6] = [
                  createTextVNode("总结")
                ])),
                _: 1
              })
            ])
          ])
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#【计算误差】" }, {
            default: withCtx(() => _cache[7] || (_cache[7] = [
              createTextVNode("【计算误差】")
            ])),
            _: 1
          }),
          createBaseVNode("ul", null, [
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#安全整数" }, {
                default: withCtx(() => _cache[8] || (_cache[8] = [
                  createTextVNode("安全整数")
                ])),
                _: 1
              }),
              createBaseVNode("ul", null, [
                createBaseVNode("li", null, [
                  createVNode(_component_router_link, { to: "#确定最大安全整数" }, {
                    default: withCtx(() => _cache[9] || (_cache[9] = [
                      createTextVNode("确定最大安全整数")
                    ])),
                    _: 1
                  })
                ])
              ])
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#小数" }, {
                default: withCtx(() => _cache[10] || (_cache[10] = [
                  createTextVNode("小数")
                ])),
                _: 1
              }),
              createBaseVNode("ul", null, [
                createBaseVNode("li", null, [
                  createVNode(_component_router_link, { to: "#number-epsilon" }, {
                    default: withCtx(() => _cache[11] || (_cache[11] = [
                      createTextVNode("Number.EPSILON")
                    ])),
                    _: 1
                  })
                ]),
                createBaseVNode("li", null, [
                  createVNode(_component_router_link, { to: "#小数误差" }, {
                    default: withCtx(() => _cache[12] || (_cache[12] = [
                      createTextVNode("小数误差")
                    ])),
                    _: 1
                  })
                ]),
                createBaseVNode("li", null, [
                  createVNode(_component_router_link, { to: "#_0-1-0-2-0-30000000000000004" }, {
                    default: withCtx(() => _cache[13] || (_cache[13] = [
                      createTextVNode("0.1 + 0.2 = 0.30000000000000004")
                    ])),
                    _: 1
                  })
                ]),
                createBaseVNode("li", null, [
                  createVNode(_component_router_link, { to: "#为什么-x-0-1-能得到-0-1" }, {
                    default: withCtx(() => _cache[14] || (_cache[14] = [
                      createTextVNode("为什么 x = 0.1 能得到 0.1")
                    ])),
                    _: 1
                  })
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#【显示误差】ieee-754是按照什么规则来实现双精度浮点数的截断显示的" }, {
            default: withCtx(() => _cache[15] || (_cache[15] = [
              createTextVNode("【显示误差】IEEE 754是按照什么规则来实现双精度浮点数的截断显示的？")
            ])),
            _: 1
          })
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#解决方案" }, {
            default: withCtx(() => _cache[16] || (_cache[16] = [
              createTextVNode("解决方案")
            ])),
            _: 1
          }),
          createBaseVNode("ul", null, [
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#数据展示类" }, {
                default: withCtx(() => _cache[17] || (_cache[17] = [
                  createTextVNode("数据展示类")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#数据运算类" }, {
                default: withCtx(() => _cache[18] || (_cache[18] = [
                  createTextVNode("数据运算类")
                ])),
                _: 1
              })
            ])
          ])
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#reference" }, {
            default: withCtx(() => _cache[19] || (_cache[19] = [
              createTextVNode("Reference")
            ])),
            _: 1
          })
        ])
      ])
    ]),
    _cache[21] || (_cache[21] = createStaticVNode('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>众所周知，JavaScript 浮点数运算时经常遇到像<code>0.000000001</code>和<code>0.999999999</code>这样奇怪的结果，如<code>0.1+0.2=0.30000000000000004</code>、<code>1-0.9=0.09999999999999998</code>，很多人知道这是浮点数误差问题，但具体就说不清楚了。本文帮你理清这背后的原理。</p><p>JavaScript 小数的不精确，主要体现在三个层面：</p><ul><li>存储，存储时是将数字转成二进制并截断，截断时可能偏大或偏小。</li><li>运算，因为存储已经导致不精确，运算时这种不精确可能抵消，也可能进一步扩大。</li><li>显示，转成十进制后的小数，在小数点后 17 位内都是准确的，超过 17 位后就不准确了。</li></ul><h2 id="【存储误差】双精度浮点数的存储" tabindex="-1"><a class="header-anchor" href="#【存储误差】双精度浮点数的存储"><span>【存储误差】双精度浮点数的存储</span></a></h2><p>首先我们来了解一下 JavaScript 是如何存储数字的。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — <code>Number</code>。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的<strong>双精度浮点数</strong>（其他的还有 32 位单精度等）。</p><p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。</p><p>64 位比特又可分为三个部分：</p><ul><li>符号位</li><li>指数位</li><li>尾数位 M：最后的 52 位是尾数（<code>mantissa</code>），超出的部分自动进一舍零</li></ul><figure><img src="' + _imports_0 + '" alt="图1" tabindex="0" loading="lazy"><figcaption>图1</figcaption></figure><h3 id="科学计数法" tabindex="-1"><a class="header-anchor" href="#科学计数法"><span>科学计数法</span></a></h3><p>实际上数字要转换成如下公式来计算和存储：</p><figure><img src="' + _imports_1 + '" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>以上的公式循序科学计数法的规范，十进制的数字转成如上公式时，0 &lt; M 的 整数部分 &lt; 10，二进制的数字换成如上公式时，0 &lt; M 的整数部分 &lt; 2。</p><p>针对二进制的公式，M 的整数部分只能是 1，所以可以被舍去，只保留后面的小数部分。</p><p>如 4.5 转换成二进制就是 100.1，科学计数法表示是 1.001*2<sup>2</sup>，舍去 1 后 M = 001。E 是一个无符号整数，因为长度是 11 位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以再减去一个中间数 1023，E 为 [0,1022] 表示为负，为 [1024,2047] 表示为正。如 4.5 的指数 E = 1025，尾数 M 为 001。</p><p>所以最终二进制存储时要转换成如下公式：</p><figure><img src="' + _imports_2 + '" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="符号位" tabindex="-1"><a class="header-anchor" href="#符号位"><span>符号位</span></a></h3><p>符号位（<code>sign</code>），占 1 比特，<code>0</code>代表正数，<code>1</code>代表负数</p><h3 id="指数位" tabindex="-1"><a class="header-anchor" href="#指数位"><span>指数位</span></a></h3><p>指数位（<code>exponent</code>），占 11 比特，用来表示 2 的次方数。</p><p>类比整数使用所有位为 0 的数字表示数值“0”，双精度浮点数表示 0 时指数部分也为 0。若如此，便可能产生冲突：比如全 0 的数字可能表示“0”，也可能表示“1 * 2<sup>0</sup> = 1”，于是此处规定：</p><ul><li>0x000: 即二进制的<code>00000000000</code>，用来代表带符号的 0（尾数为 0）或下溢数（尾数不为 0）。</li><li>0x7ff: 即二进制的<code>11111111111</code>，用来代表无穷大（尾数为 0）或NaN（尾数不为 0）。</li><li>其他: 即二进制的<code>00000000001</code>-<code>11111111110</code>代表 2 的<code>exponent-0x3ff</code>次方。</li></ul><p>之所以要减去<code>0x3ff</code>，是因为指数还需要表示负数。在因此指数位里，二进制的<code>10000000000</code>~<code>11111111110</code>，即十进制的<code>1024</code>~<code>2046</code>，代表指数表示正数，二进制<code>00000000001</code>~<code>01111111110</code>，即十进制的<code>1</code>~<code>1022</code>，代表指数表示负数。</p><h3 id="尾数位" tabindex="-1"><a class="header-anchor" href="#尾数位"><span>尾数位</span></a></h3><p>尾数位（<code>mantissa</code>），占 52 比特，用来表示二进制科学计算法 Mantissa 部分<code>1.</code>后面的数字。</p><p>在二进制的科学计数法里，数字被表示为：</p><p>Mantissa * 2<sup>exponent</sup></p><p>为了最大限度提高精确度，可以要求尾数规范化，把尾数处理到大于等于<code>1</code>而小于<code>2</code>的区间内，便可省去前述的“1”。例如：</p><blockquote><p>二进制的 11.101 <em>2<sup>1001</sup> 可以规范化为 1.1101</em> 2<sup>1010</sup> ，\b存储尾数则只需要存储 1101 即可</p><p>二进制的 0.00110011 <em>2<sup>-1001</sup> 可以规范化为 1.10011</em> 2<sup>-1100</sup> ，存储尾数则只需要存储 10011 即可</p></blockquote><p>于是，可得到以下形式: 1.mantissa * 2<sup>exponent</sup></p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>根据以上的叙述，一个双精度浮点数所代表的数值为：(-1)<sup>sign</sup> <em>2<sup>exponent - 0x3ff</sup></em> 1.mantissa</p><p>比如，十进制的 4.5，转换成二级制则为 100.1，表示为二进制的科学计数法为，1.001 * 2<sup>2</sup> ，因此，<code>sign</code>为<code>0</code>，<code>exponent</code>为二进制的<code>10000000001</code>即十进制的<code>1023 + 2 = 1025</code>，<code>mantissa</code>为二进制<code>001</code>（后面再跟 49 个 0）</p><figure><img src="' + _imports_3 + '" alt="4.5" tabindex="0" loading="lazy"><figcaption>4.5</figcaption></figure><p>需要注意的是，<code>mantissa</code>若是超过 52 位，会判断第 53 位，若是 1 则进 1，若是 0 则舍去。</p><p>比如对于<code>0.1</code>，其二进制表示为<code>0.00011001100110011001100110011001100110011001100110011001100...（1100无限循环）</code>，表示成二级制科学计数法为</p><p>1.10011001100110011001100110011001100110011001100110011【注意，第 53 为是 1】00...（1100无限循环）* 2<sup>-4</sup></p><p>因为第 53 为是 1，因此最终要进 1，变成了</p><p>1.1001100110011001100110011001100110011001100110011010 * 2<sup>-4</sup></p><p>符号位、指数位、尾数位分别为：</p><figure><img src="' + _imports_4 + '" alt="0.1" tabindex="0" loading="lazy"><figcaption>0.1</figcaption></figure><p>也就是说，<code>0.1</code>经过转换存储后再转为十进制数，实际上比原先的<code>0.1</code>要略大！</p><h2 id="【计算误差】" tabindex="-1"><a class="header-anchor" href="#【计算误差】"><span>【计算误差】</span></a></h2><p>因为浮点数在存储时已经不精确了，因此在计算时这种不精确可能进一步放大，或者抵消。</p><p>比如：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &#39;0.29999999999999998889776975374843&#39;，存储时比实际值要小</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// &#39;0.10000000000000000555111512312578&#39;，存储时比实际值要大</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.3</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0.2</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 0.09999999999999998，导致运算后，不精确进一步扩大</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.3</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0.1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 0.4，不精确抵消了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="安全整数" tabindex="-1"><a class="header-anchor" href="#安全整数"><span>安全整数</span></a></h3><p>所谓“安全整数”，就是说该整数与其双精度浮点数表示是一一对应的，即该整数有且仅有一个双精度浮点数表示，其该双精度浮点数表示有且仅有一个对应的整数。</p><p>安全整数的范围是(-2<sup>53</sup>, 2<sup>53</sup>)，不包括两端的取值。超过这个范围，有的整数是无法精确表示的，只能<code>round</code>到与它相近的双精度浮点数，其结果就是，超过一个的整数对应同一个双精度浮点数。</p><p>JavaScript 的<code>Number</code>构造函数上有如下两个静态属性:</p><ul><li><code>Number.MAX_VALUE</code>: 常量，其值为<code>1.7976931348623157e+308</code>，表示 JavaScript 里所能表示的最大数值。</li><li><code>Number.MAX_SAFE_INTEGER</code>: 常量，其值为<code>9007199254740991</code>，即 2<sup>53</sup> - 1，表示 JavaScript 里所能表示的最大安全整数。</li></ul><h4 id="确定最大安全整数" tabindex="-1"><a class="header-anchor" href="#确定最大安全整数"><span>确定最大安全整数</span></a></h4><p>但是，安全整数的范围是如何确定的呢？基于上面双精度浮点数存储的知识，我们试图来确定一下最大安全整数。</p><p>我们知道，尾数的最大值是为 52 个 1，加上规范化时省略的 1，共计 53 个 1，因此其能表示的最大整数的二进制科学计数法表示为：</p><p>1.{52个1} * 2<sup>exponent - 0x3ff </sup></p><p>其中，小数点之前是 1 个 1，小数点后是 52 个 1。<code>exponent</code>为指数，其取值为<code>0 &lt; exponent &lt; 2047</code>，因此，其所能表示的最大整数用二进制科学计数法表示为</p><p>1.{52个1} <em>2<sup>2046 - 0x3ff</sup> = 1.{52个1}</em> 2<sup>1023</sup> = (2<sup>53</sup>-1) <em>2<sup>1023 - 52</sup> = (2<sup>53</sup>-1)</em> 2<sup>971</sup></p><p>上面这个数，表示成二进制就是 53 个 1 后面加上 971 个 0；表示成十进制是 1.7976931348623157e+308，即 1.7976931348623157 * 10<sup>308</sup>。</p><p>但是，能表示的最大整数并不都是安全的。事实上，超过大于 2<sup>53</sup>-1 的整数都是不安全整数。</p><table><thead><tr><th>十进制数</th><th>二进制数</th><th>科学计算法</th><th>存储时的指数值(十进制)和尾数值(二进制)</th></tr></thead><tbody><tr><td>2<sup>53</sup>-3</td><td>{51个1}01</td><td>1.{50个1}01 * 2<sup>52</sup></td><td><code>exponent</code>: 52 + 1023<br><code>mantissa</code>: 50个1, 后跟01<br>（整数与浮点数一一对应，安全整数）</td></tr><tr><td>2<sup>53</sup>-2</td><td>{51个1}10</td><td>1.{50个1}10 * 2<sup>52</sup></td><td><code>exponent</code>: 52 + 1023<br><code>mantissa</code>: 50个1, 后跟10<br>（整数与浮点数一一对应，安全整数）</td></tr><tr><td>2<sup>53</sup>-1</td><td>{51个1}11</td><td>1.{50个1}11 * 2<sup>52</sup></td><td><code>exponent</code>: 52 + 1023<br><code>mantissa</code>: 50个1, 后跟11<br>（整数与浮点数一一对应，安全整数）</td></tr><tr><td>2<sup>53</sup></td><td>1{53个0}</td><td>1.{53个0} * 2<sup>53</sup></td><td><code>exponent</code>: 53 + 1023<br><code>mantissa</code>: 52 个 0<br>（只有 52 比特，最后一个 0 被省略了）<br>（两个整数对应一个浮点数，不安全整数）</td></tr><tr><td>2<sup>53</sup> + 1</td><td>1 {52个0} 1</td><td>1.{52个0}1 * 2<sup>53</sup></td><td><code>exponent</code>: 53 + 1023<br><code>mantissa</code>: 52 个 0<br>（只有 52 比特，最后一个 1 被省略了）<br>（两个整数对应一个浮点数，不安全整数）</td></tr><tr><td>2<sup>53</sup> + 2</td><td>1 {51个0} 10</td><td>1.{51个0}10 * 2<sup>53</sup></td><td><code>exponent</code>: 53 + 1023<br><code>mantissa</code>: 51 个 0, 1 个 1<br>（只有 52 比特，最后一个 0 被省略了）<br>（两个整数对应一个浮点数，不安全整数）</td></tr><tr><td>2<sup>53</sup> + 3</td><td>1 {51个0} 11</td><td>1.{51个0}11 * 2<sup>53</sup></td><td><code>exponent</code>: 53 + 1023<br><code>mantissa</code>: 51 个 0, 1 个 1<br>（只有 52 比特，最后一个 1 被省略了）<br>（两个整数对应一个浮点数，不安全整数）</td></tr></tbody></table><p>上表里，小于等于 2<sup>53</sup>-1 的整数，都能找到一一对应的双精度浮点数。但是 2<sup>53</sup> 及以后的整数，一个双精度浮点数都能对应多个整数。比如我们在控制台里测试 2<sup>53</sup> 与 2<sup>53</sup> + 1 是否相等：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">===</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>事实上，因为尾数位只能 52 位，导致超过 52 位都会被省略，因此，</p><p>(2<sup>53</sup> ~ 2<sup>54</sup>) 之间的数，只能精确表示 2<sup>1</sup> 的倍数，即偶数</p><p>(2<sup>54</sup> ~ 2<sup>55</sup>) 之间的数，只能精确表示 2<sup>2</sup> 的倍数，即 4 的倍数</p><p>(2<sup>55</sup> ~ 2<sup>56</sup>) 之间的数，只能精确表示 2<sup>3</sup> 的倍数，即 8 的倍数</p><p>以此类推...</p><p>因此，最大安全整数是 2<sup>53</sup> - 1，最小安全整数是 -(2<sup>53</sup> - 1)</p><div class="hint-container warning"><p class="hint-container-title">警告</p><p>超过 2<sup>53</sup> - 1 之后，计算结果不能确保其正确性。在控制台打印 Math.pow(2, 53) 之后的 10 个数，发现并不是两个整数对应一个结果。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254740992</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 1</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254740992</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 2</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254740994</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 3</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254740996</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 4</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254740996</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 5</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254740996</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 6</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254740998</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 7</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254741000</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 8</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254741000</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 9</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254741000</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; Math.pow(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 53</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) + 10</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">9007199254741002</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>整数</th><th>实际打印结果</th><th>存储之前的二级制</th><th>实际存储的二级制</th></tr></thead><tbody><tr><td>Math.pow(2, 53)</td><td>9007199254740992</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...0000 （53 个 0）</td><td><code>mantissa</code>: 52 个 0</td></tr><tr><td>Math.pow(2, 53) + 1</td><td>9007199254740992</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...0001 （52 个 0 + 1）</td><td><code>mantissa</code>: 52 个 0</td></tr><tr><td>Math.pow(2, 53) + 2</td><td>9007199254740994</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...0010 （51 个 0 + 10）</td><td><code>mantissa</code>: 51 个 0 + 1</td></tr><tr><td>Math.pow(2, 53) + 3</td><td>9007199254740996</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...0011 （51 个 0 + 11）</td><td><code>mantissa</code>: 50 个 0 + 10</td></tr><tr><td>Math.pow(2, 53) + 4</td><td>9007199254740996</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...0100 （50 个 0 + 100）</td><td><code>mantissa</code>: 50 个 0 + 10</td></tr><tr><td>Math.pow(2, 53) + 5</td><td>9007199254740996</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...0101 （50 个 0 + 101）</td><td><code>mantissa</code>: 50 个 0 + 10</td></tr><tr><td>Math.pow(2, 53) + 6</td><td>9007199254740998</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...0110 （50 个 0 + 110）</td><td><code>mantissa</code>: 50 个 0 + 11</td></tr><tr><td>Math.pow(2, 53) + 7</td><td>9007199254741000</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...0111 （50 个 0 + 111）</td><td><code>mantissa</code>: 49 个 0 + 100</td></tr><tr><td>Math.pow(2, 53) + 8</td><td>9007199254741000</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...1000 （49 个 0 + 1000）</td><td><code>mantissa</code>: 49 个 0 + 100</td></tr><tr><td>Math.pow(2, 53) + 9</td><td>9007199254741000</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...1001 （49 个 0 + 1001）</td><td><code>mantissa</code>: 49 个 0 + 100</td></tr><tr><td>Math.pow(2, 53) + 10</td><td>9007199254741002</td><td><code>exponent</code>: 52 + 1023，<code>mantissa</code>: 000...1010 （49 个 0 + 1010）</td><td><code>mantissa</code>: 49 个 0 + 101</td></tr></tbody></table><p>到这里，可以大致猜测，在<code>mantissa</code>的第 52 位和第 53 位都为 1 时，会进 1 位，而其他情况则舍去，因此会出现每相邻的 4 个数中，有 3 个数是一样的。</p><p>通过上面的表格，你可能会疑惑，什么时候会进 1 或舍弃？</p><p>这里就要使用到【 Round to Even 向偶舍入】算法。向偶舍入，舍入的值保证最靠近原浮点数值，如果舍入为中间值，即舍还是入距离相等，那么按其末尾一位是奇数则入，如果是偶数则舍。</p><p>下面用例子说明：</p><p>x.zzzzy10000,</p><p>x 为整数任意值，二进制时一般为 1。</p><p>z 和 y 为任意值，二进制时一般为 0 或 1。</p><p>最末尾 y 为需要保留的最后一位。最尾数 y 后续数值（即上面的 10000）情况说明如下：</p><ul><li>10001：只要第一个 1 后续数字包含有 1，则说明最尾数 y 的后续数值 &gt; y/2，则 y 进 1。</li><li>0xxxx：如果第一个为 0，即不管后续数字为多少，必然说明最尾数 y 后续数值 &lt; y/2，即尾数还是保持 y。</li><li>10000：如果第一个是 1，但后续的值均为 0，则或说明其后续的值 = y/2，这时候说明舍入的距离都是相同的，这时候查看 y 的值，如果 y 为 1 则 y 进 1，如果 y 为 0 则 y 为 0。</li></ul></div><h3 id="小数" tabindex="-1"><a class="header-anchor" href="#小数"><span>小数</span></a></h3><h4 id="number-epsilon" tabindex="-1"><a class="header-anchor" href="#number-epsilon"><span>Number.EPSILON</span></a></h4><p>ES6 在<code>Number</code>对象上面，新增一个极小的常量<code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p><p>1 的二进制科学计算法表示为：1.00...00 <em>2<sup>0</sup>，其中<code>mantissa</code>为 52 个 0。<br> 比 1 大的最小浮点数为：1.00...01</em> 2<sup>0</sup>，其中<code>mantissa</code>为 51 个 0 和 1 个 1。</p><p>因此，<code>Number.EPSILON</code> = (1 + 2<sup>-52</sup>) - 1 = 2<sup>-52</sup></p><p>即 IEEE 754 双精度浮点数在转为十进制时，最小精度为 2<sup>-52</sup>，即 2.220446049250313e-16，这也就意味着，(1, 1 + 2<sup>-52</sup> )之间的十进制数，对应的是同一个双精度浮点数。</p><p>进一步我们可以知道，当数字越来越大时，一个双精度浮点数对应的十进制的数值范围就越大，比如比 1023 大的最小浮点数是 1023 + 2<sup>-43</sup>，因此（1023, 1023 + 2<sup>-43</sup>）之间的十进制数，对应的是同一个双精度浮点数。</p><p>解释：十进制的 1023 转换为二进制为 1111111111，转为双精度浮点数是：1.111111111 <em>2<sup>-9</sup>，其<code>mantissa</code>为 9 个 1。而<code>mantissa</code>最多是 52 位，若是超过 52 位，第 53 位之后都会被直接舍去，只判断第 53 位，若是 1 则进 1，若是 0 则舍去。因此比 1023 大的最小浮点数是：1.111111111{42个0}1</em> 2<sup>-9</sup>，即十进制的 1023 + 2<sup>-43</sup>。（若存在第 53 位为 0，即 1.111111111{42个0}10 <em>2<sup>-9</sup>，第 53 位 0 会被舍去，等同于 1.111111111{42个0}1</em> 2<sup>-9</sup>；若存在第 53 位为 1，即 1.111111111{42个0}11 <em>2<sup>-9</sup>，第 53 位会进 1，最后变成 1.111111111{41个0}10</em> 2<sup>-9</sup>，这个数比 1.111111111{42个0}1 * 2<sup>-9</sup>还要大）</p><h4 id="小数误差" tabindex="-1"><a class="header-anchor" href="#小数误差"><span>小数误差</span></a></h4><p>我们先以 0.1 为例，解析浮点误差的原因。0.1 转换为二进制表示为 0.0001100110011001100（1100 循环），表示为二进制的科学计数法为，1.100110011001100 * 2<sup>-4</sup>，所以<code>exponent</code>为<code>-4 + 1023 = 1019</code>；<code>mantissa</code>舍去小数点左边的 1，得到 100110011001100（1100 循环），且<code>mantissa</code>的第 53 位是 1，因此会进位，最终存储时就是:</p><figure><img src="' + _imports_4 + '" alt="0.1" tabindex="0" loading="lazy"><figcaption>0.1</figcaption></figure><p>再从存储里取出，转换为十进制后就为<code>0.100000000000000005551115123126</code>，因此就出现了浮点误差。</p><h4 id="_0-1-0-2-0-30000000000000004" tabindex="-1"><a class="header-anchor" href="#_0-1-0-2-0-30000000000000004"><span>0.1 + 0.2 = 0.30000000000000004</span></a></h4><p>JavaScript 里关于数字的运算，都是先转为二进制，再转成二进制的科学计数法进行存储，再取出存储值转为二级制，最后进行运算。而在先存储再取出值的过程中，就可能丢失精度。</p><p><code>0.1</code>和<code>0.2</code>存储后转为二进制的形式为：</p><p><code>0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010</code> +</p><p><code>0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 010</code> =</p><p><code>0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 111</code></p><p>计算结果转换为十进制，正好是<code>0.30000000000000004</code></p><h4 id="为什么-x-0-1-能得到-0-1" tabindex="-1"><a class="header-anchor" href="#为什么-x-0-1-能得到-0-1"><span>为什么 x = 0.1 能得到 0.1</span></a></h4><p>因为<code>mantissa</code>固定长度是 52 位，二进制科学计数法可能会出现这样的数据:</p><p>1.{51个0}1 * 2<sup>0</sup>，（即<code>exponent</code>为十进制的<code>1023</code>，<code>mantissa</code>为二进制的<code>{51个0}1</code>），转换为十进制就是 2<sup>0</sup> + 2<sup>-52</sup></p><p>也就是说，转化为十进制时，小数的精度为 2<sup>-52</sup>，即 2.220446049250313e-16。</p><p>因此，当数字转换为十进制时，JavaScript 能表示的精度最多能精确到小数点后第 16 位。也就是说，会将小数点后的第 17 位进行凑整处理。</p><p>我们将<code>0.1</code>~<code>0.9</code>指定 21 位有效数字，查看其值是多少。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">21</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.100000000000000005551</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">21</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.200000000000000011102</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">21</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.299999999999999988898</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">21</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.400000000000000022204</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">21</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.500000000000000000000</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">21</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.599999999999999977796</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">21</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.699999999999999955591</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">21</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.800000000000000044409</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">21</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.900000000000000022204</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，在对小数点后的第 17 位进行凑整处理后，实际上就是:</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.10000000000000000555</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 0.1000000000000000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>也就是<code>0.1</code>，因此，正常打印<code>0.1</code>~<code>0.9</code></p><h2 id="【显示误差】ieee-754是按照什么规则来实现双精度浮点数的截断显示的" tabindex="-1"><a class="header-anchor" href="#【显示误差】ieee-754是按照什么规则来实现双精度浮点数的截断显示的"><span>【显示误差】IEEE 754是按照什么规则来实现双精度浮点数的截断显示的？</span></a></h2><p>在<code>Number.EPSILON</code>一节我们知道，双精度浮点数的小数精度为 2<sup>-52</sup>，即 2.220446049250313e-16，但是在将双精度浮点数转换为十进制的数字字符串时，小数点后要保留多少位有效数字呢？我们先来看看浏览器控制台的一组计算及其返回：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>0.1 + 0.2 = 0.30000000000000004     // 17 位有效数字</span></span>\n<span class="line"><span>100.27 * 0.41 = 41.110699999999994  // 17 位有效数字</span></span>\n<span class="line"><span>0.95 * 1 / 3 = 0.31666666666666665  // 17 位有效数字</span></span>\n<span class="line"><span>300.73 - 300 = 0.7300000000000182   // 16 位有效数字</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事实上以上例子打印出的结果均是真实算数结果的近似值，然而却有不同的有效数字位；在浏览器控制台里输入<code>0.1</code> ，而我们也明白这个不是精确的值，而控制台依然显示的是<code>0.1</code>，不显示<code>0.10000000000000001</code>。很明显，在控制台输出的浮点数近似值都是经过一定的规则来截断的。同时这种表现不仅限于 JS，大家可以在 Terminal 中尝试一下，所有采用 IEEE 754 双精度浮点数标准的语言如 Node 和 Python 都有同样的表现。那么，IEEE 754是按照什么规则来实现双精度浮点数的截断的？</p><p>在 IEEE 754 规范的 Wiki 页面里看到对浮点数和十进制字符串转换的描述有这么一段：</p><blockquote><p>The standard requires operations to convert between basic formats and external character sequence formats. Conversions to and from a decimal character format are required for all formats. Conversion to an external character sequence must be such that conversion back using round to even will recover the original number. There is no requirement to preserve the payload of a NaN or signaling NaN, and conversion from the external character sequence may turn a signaling NaN into a quiet NaN. The original binary value will be preserved by converting to decimal and back again using 17 decimal digits for binary64.</p></blockquote><p>IEEE 754 规定，浮点数被转成十进制数字字符串，当这个字符串（使用 Round to Even 向偶舍入）转回浮点数时，必须要跟原来的数相同。<strong>对双精度浮点数来说，十进制字符串使用17位有效数字即可保存原始二进制值。</strong></p><p>我们来做个实验，以<code>0.1</code>为例，它在内存中的二进制表示转换为十进制的数字字符串为：<code>0.1000000000000000055511151231257827021181583404541015625</code></p><p>当我们获取它的 17 位(经过舍入的)有效数为<code>0.10000000000000001</code>，那为什么控制台不显示<code>0.10000000000000001</code>而显示<code>0.1</code>？</p><p><strong>事实上，有许多不同的十进制数共享相同的最接近的近似二进制小数</strong>，在这个例子里，<code>0.1</code>、<code>0.10000000000000001</code>、<code>0.1000000000000000055511151231257827021181583404541015625</code>分别在内存中的 64bit 都是完全相同的，在大多数系统上现在能够选择这些表示中最短的来展示，也就是<code>0.1</code>。因此可以推断出：截断判断的依据是截断后的数在<code>console</code>里打印成字符串，这个字符串再转回浮点数后，是否还是同一个数。</p><p>说人话就是：在<code>console</code>里打印出来的，就是可以表示这个浮点数的最短的字符串！</p><p>这就解释了为啥<code>console</code>里有些浮点数的计算得出 17 位有效位，有些只有 16 位，有些直接显示自己本身。</p><p>自我理解：当一个浮点数要转换成十进制的字符串时，并不是采用简单的四舍五入算法，而是会找到与这个数字最接近的近似二进制小数，这个二进制小数一定是 2<sup>-52</sup>（即 2.220446049250313e-16）的倍数，最后显示的是这个近似的二进制小数转换成的十进制字符串。</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h2><p>回到最关心的问题：如何解决浮点误差。首先，理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果。</p><h3 id="数据展示类" tabindex="-1"><a class="header-anchor" href="#数据展示类"><span>数据展示类</span></a></h3><p>当你拿到 1.4000000000000001 这样的数据要展示时，建议使用<code>toPrecision</code>凑整并<code>parseFloat</code>转成数字后再显示，如下：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">parseFloat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.4000000000000001</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">12</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">===</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1.4</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // True</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>封装成方法就是：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> strip</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">num</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">precision</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 12</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">parseFloat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">num</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrecision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">precision</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么选择 12 做为默认精度？这是一个经验的选择，一般选 12 就能解决掉大部分 0001 和 0009 问题，而且大部分情况下也够用了，如果你需要更精确可以调高。</p><h3 id="数据运算类" tabindex="-1"><a class="header-anchor" href="#数据运算类"><span>数据运算类</span></a></h3><p>对于运算类操作，如<code>+-*/</code>，就不能使用<code>toPrecision</code>了。正确的做法是把小数转成整数后再运算。以加法为例：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/**</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 精确加法</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> */</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">num1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">num2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> num1Digits</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">num1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">split</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;.&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">](</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> num2Digits</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">num2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">split</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;.&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">](</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> baseNum</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> **</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">max</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">num1Digits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">num2Digits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">num1</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> baseNum</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> num2</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> baseNum</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> baseNum</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上方法能适用于大部分场景。遇到科学计数法如<code>2.3e+1</code>（当数字精度大于 21 时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。</p><p>遇到浮点数误差问题时可以直接使用<a href="https://github.com/nefe/number-precision" target="_blank" rel="noopener noreferrer">number-precision</a>。完美支持浮点数的加减乘除、四舍五入等运算。非常小只有 1K，远小于绝大多数同类库（如 Math.js、BigDecimal.js），100% 测试全覆盖，代码可读性强，不妨在你的应用里用起来！</p><p>其他的一些库：</p><ul><li><a href="https://github.com/MikeMcl/bignumber.js/" target="_blank" rel="noopener noreferrer">bignumber.js</a></li><li><a href="https://github.com/MikeMcl/big.js/" target="_blank" rel="noopener noreferrer">big.js</a></li><li><a href="https://github.com/MikeMcl/decimal.js/" target="_blank" rel="noopener noreferrer">decimal.js</a></li><li><a href="https://github.com/nefe/number-precision" target="_blank" rel="noopener noreferrer">number-precision</a></li></ul><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h2><ul><li><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener noreferrer">JavaScript 浮点数陷阱及解法 #9</a></li><li><a href="http://bartaz.github.io/ieee754-visualization/" target="_blank" rel="noopener noreferrer">IEEE 754 双精度浮点数可视化工具</a></li><li><a href="https://jacelyn.fish/2019/06/08/ieee-floating-point-number/" target="_blank" rel="noopener noreferrer">从计组课到前端深坑：IEEE 754双精度浮点数的那些事</a></li><li><a href="https://blog.csdn.net/qq_16097611/article/details/52373936" target="_blank" rel="noopener noreferrer">IEEE 754 round-to-nearest-even</a></li><li><a href="https://zhuanlan.zhihu.com/p/66949640" target="_blank" rel="noopener noreferrer">前端应该知道的JavaScript浮点数和大数的原理</a></li></ul>', 130)),
    createVNode(_component_global_config)
  ]);
}
const floating_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "floating.html.vue"]]);
const data = JSON.parse('{"path":"/js/data-types/number/floating.html","title":"JavaScript 关于 IEEE 754 双精度浮点数的实现","lang":"en-US","frontmatter":{"description":"JavaScript 关于 IEEE 754 双精度浮点数的实现 简介 众所周知，JavaScript 浮点数运算时经常遇到像0.000000001和0.999999999这样奇怪的结果，如0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体就说不清楚了。本文帮...","head":[["meta",{"property":"og:url","content":"https://blog.windstone.cc/js/data-types/number/floating.html"}],["meta",{"property":"og:site_name","content":"风动之石的博客"}],["meta",{"property":"og:title","content":"JavaScript 关于 IEEE 754 双精度浮点数的实现"}],["meta",{"property":"og:description","content":"JavaScript 关于 IEEE 754 双精度浮点数的实现 简介 众所周知，JavaScript 浮点数运算时经常遇到像0.000000001和0.999999999这样奇怪的结果，如0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体就说不清楚了。本文帮..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-10-09T06:46:21.000Z"}],["meta",{"property":"article:modified_time","content":"2024-10-09T06:46:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JavaScript 关于 IEEE 754 双精度浮点数的实现\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-09T06:46:21.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"【存储误差】双精度浮点数的存储","slug":"【存储误差】双精度浮点数的存储","link":"#【存储误差】双精度浮点数的存储","children":[{"level":3,"title":"科学计数法","slug":"科学计数法","link":"#科学计数法","children":[]},{"level":3,"title":"符号位","slug":"符号位","link":"#符号位","children":[]},{"level":3,"title":"指数位","slug":"指数位","link":"#指数位","children":[]},{"level":3,"title":"尾数位","slug":"尾数位","link":"#尾数位","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"【计算误差】","slug":"【计算误差】","link":"#【计算误差】","children":[{"level":3,"title":"安全整数","slug":"安全整数","link":"#安全整数","children":[]},{"level":3,"title":"小数","slug":"小数","link":"#小数","children":[]}]},{"level":2,"title":"【显示误差】IEEE 754是按照什么规则来实现双精度浮点数的截断显示的？","slug":"【显示误差】ieee-754是按照什么规则来实现双精度浮点数的截断显示的","link":"#【显示误差】ieee-754是按照什么规则来实现双精度浮点数的截断显示的","children":[]},{"level":2,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[{"level":3,"title":"数据展示类","slug":"数据展示类","link":"#数据展示类","children":[]},{"level":3,"title":"数据运算类","slug":"数据运算类","link":"#数据运算类","children":[]}]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]}],"git":{"createdTime":1555234266000,"updatedTime":1728456381000,"contributors":[{"name":"wind-stone","email":"wind-stone@qq.com","commits":4}]},"readingTime":{"minutes":18.86,"words":5659},"filePathRelative":"js/data-types/number/floating.md","localizedDate":"April 14, 2019","autoDesc":true}');
export {
  floating_html as comp,
  data
};
