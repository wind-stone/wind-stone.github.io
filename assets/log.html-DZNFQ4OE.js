import { r as resolveComponent, c as createElementBlock, d as createBaseVNode, a as createVNode, e as withCtx, b as createStaticVNode, o as openBlock, f as createTextVNode } from "./app-Dscgj__W.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _sfc_main = {};
const _hoisted_1 = { class: "table-of-contents" };
function _sfc_render(_ctx, _cache) {
  const _component_router_link = resolveComponent("router-link");
  const _component_global_config = resolveComponent("global-config");
  return openBlock(), createElementBlock("div", null, [
    _cache[4] || (_cache[4] = createBaseVNode("h1", {
      id: "日志",
      tabindex: "-1"
    }, [
      createBaseVNode("a", {
        class: "header-anchor",
        href: "#日志"
      }, [
        createBaseVNode("span", null, "日志")
      ])
    ], -1)),
    createBaseVNode("nav", _hoisted_1, [
      createBaseVNode("ul", null, [
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#为什么浏览器通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片" }, {
            default: withCtx(() => _cache[0] || (_cache[0] = [
              createTextVNode("为什么浏览器通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？")
            ])),
            _: 1
          })
        ]),
        createBaseVNode("li", null, [
          createVNode(_component_router_link, { to: "#元素日志" }, {
            default: withCtx(() => _cache[1] || (_cache[1] = [
              createTextVNode("元素日志")
            ])),
            _: 1
          }),
          createBaseVNode("ul", null, [
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#元素曝光日志" }, {
                default: withCtx(() => _cache[2] || (_cache[2] = [
                  createTextVNode("元素曝光日志")
                ])),
                _: 1
              })
            ]),
            createBaseVNode("li", null, [
              createVNode(_component_router_link, { to: "#元素点击日志" }, {
                default: withCtx(() => _cache[3] || (_cache[3] = [
                  createTextVNode("元素点击日志")
                ])),
                _: 1
              })
            ])
          ])
        ])
      ])
    ]),
    _cache[5] || (_cache[5] = createStaticVNode('<h2 id="为什么浏览器通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片" tabindex="-1"><a class="header-anchor" href="#为什么浏览器通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片"><span>为什么浏览器通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</span></a></h2><p>谷歌和百度等都是通过<code>new Image()</code>的方式请求<code>1x1</code>像素的透明<code>gif</code>图片的方式来发送埋点数据，而服务器端一般用一个<code>1x1</code>的<code>gif</code>图片来作为响应，但这有点浪费服务器资源；因此用<code>header</code>来响应比较合适，目前比较合适的做法是服务器端发送&quot;204 No Content&quot;，即“服务器成功处理了请求，但不需要返回任何实体内容”。</p><ul><li>为什么是图片？ <ul><li>请求图片，没有跨域问题</li><li>请求图片，不会阻塞页面加载</li><li>图片请求发出即可，也不需要等待服务器返回任何数据</li><li>相比 XMLHttpRequest 对象发送 GET 请求，性能上更好</li></ul></li><li>更进一步，为什么是 gif ？ <ul><li>gif 的最低合法体积最小 <ul><li>最小的 BMP 文件需要 74 个字节</li><li>最小的 PNG 需要 67 个字节</li><li>而合法的 GIF，只需要 43 个字节</li></ul></li></ul></li></ul><h2 id="元素日志" tabindex="-1"><a class="header-anchor" href="#元素日志"><span>元素日志</span></a></h2><p>元素的曝光和点击日志，可使用 Vue.js 的指令实现。</p><h3 id="元素曝光日志" tabindex="-1"><a class="header-anchor" href="#元素曝光日志"><span>元素曝光日志</span></a></h3><p>借助<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener noreferrer">Intersection Observer</a>判断元素是否进入可视区域，进而发送曝光埋点。</p><p>实现时需要注意：</p><ul><li>提供修饰符，来按需确定元素是否需要重复发送曝光埋点（页面上下滑导致元素多次曝光），可以用 WeakMap 来记录元素是否发送过曝光埋点</li><li>提供修饰符，来按需在埋点数据发生响应式变化时重新发送埋点</li></ul><h3 id="元素点击日志" tabindex="-1"><a class="header-anchor" href="#元素点击日志"><span>元素点击日志</span></a></h3><p>实现时需要注意：</p><ul><li>针对点击后跳转的情况，需要在跳转之前发送埋点</li></ul><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// onClick 一般是公司级的埋点工具提供的方法，用于发送点击埋点</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> handleClick</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">e</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dom</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">currentTarget</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HTMLElement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    dom</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> dom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">__clickData</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onClick</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">dom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">__clickData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Vue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">directive</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;log-click&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    inserted</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">el</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HTMLElement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, { </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        el</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">__clickData</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        el</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">addEventListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;click&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">handleClick</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    },</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 在指令所在组件的 VNode 及其子 VNode 全部更新后调用，更新点击数据</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    componentUpdated</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">el</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, { </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">oldValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        el</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">__clickData</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    },</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 指令与元素解绑时调用</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    unbind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">el</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        el</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">removeEventListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;click&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">handleClick</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    },</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>', 13)),
    createVNode(_component_global_config)
  ]);
}
const log_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "log.html.vue"]]);
const data = JSON.parse('{"path":"/js/error-handling/log.html","title":"日志","lang":"en-US","frontmatter":{"description":"日志 为什么浏览器通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？ 谷歌和百度等都是通过new Image()的方式请求1x1像素的透明gif图片的方式来发送埋点数据，而服务器端一般用一个1x1的gif图片来作为响应，但这有点浪费服务器资源；因此用header来响应比较合适，目前比较合适的做法是服务器端发送\\"204 No Con...","head":[["meta",{"property":"og:url","content":"https://blog.windstone.cc/js/error-handling/log.html"}],["meta",{"property":"og:site_name","content":"风动之石的博客"}],["meta",{"property":"og:title","content":"日志"}],["meta",{"property":"og:description","content":"日志 为什么浏览器通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？ 谷歌和百度等都是通过new Image()的方式请求1x1像素的透明gif图片的方式来发送埋点数据，而服务器端一般用一个1x1的gif图片来作为响应，但这有点浪费服务器资源；因此用header来响应比较合适，目前比较合适的做法是服务器端发送\\"204 No Con..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2021-12-22T09:40:18.000Z"}],["meta",{"property":"article:modified_time","content":"2021-12-22T09:40:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"日志\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2021-12-22T09:40:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"为什么浏览器通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？","slug":"为什么浏览器通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片","link":"#为什么浏览器通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片","children":[]},{"level":2,"title":"元素日志","slug":"元素日志","link":"#元素日志","children":[{"level":3,"title":"元素曝光日志","slug":"元素曝光日志","link":"#元素曝光日志","children":[]},{"level":3,"title":"元素点击日志","slug":"元素点击日志","link":"#元素点击日志","children":[]}]}],"git":{"createdTime":1555062701000,"updatedTime":1640166018000,"contributors":[{"name":"wind-stone","email":"wind-stone@qq.com","commits":2}]},"readingTime":{"minutes":1.97,"words":592},"filePathRelative":"js/error-handling/log.md","localizedDate":"April 12, 2019","autoDesc":true}');
export {
  log_html as comp,
  data
};
